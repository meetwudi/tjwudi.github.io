<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[回田园 - 子回的私人创作]]></title>
  <subtitle><![CDATA[创造是我最大的兴趣]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.leapoahead.com/"/>
  <updated>2016-07-31T06:14:43.000Z</updated>
  <id>http://blog.leapoahead.com/</id>
  
  <author>
    <name><![CDATA[子回]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Node.js与Docker从开发到生产（1）]]></title>
    <link href="http://blog.leapoahead.com/2016/07/30/nodejs-docker-from-scratch-to-production/"/>
    <id>http://blog.leapoahead.com/2016/07/30/nodejs-docker-from-scratch-to-production/</id>
    <published>2016-07-30T03:19:53.000Z</published>
    <updated>2016-07-31T06:14:43.000Z</updated>
    <content type="html"><![CDATA[<p>Docker在前几天发布了Mac和Windows的版本，从此Mac用户可以无需安装VirtualBox使用Docker。这给更多对Docker只闻其名但未曾尝试的朋友更方便地动手尝试的机会。本文将带你了解Docker，并一步步使用Docker将一个Node.js应用部署到生产环境中。</p>
<a id="more"></a>
<h3 id="什么是Docker">什么是Docker</h3><p>为了让更多读者能够跟随本文的步伐，我有必要阐述什么是Docker。如果你已经有所了解，或者想立刻动手实践，可以直接跳到第2节。</p>
<p>我们从真实的生产环境说起。当一个应用刚上线的时候，或许一台服务器还是够用的。但随着活跃用户数的增长，一台服务器不够用了，我们可能需要两台、十台甚至几百台的服务器来支撑一个应用。</p>
<p>在这几百台服务器中，每台服务器的系统配置都是可以能有细微差异的。尽管一开始安装系统的时候采用的是同一种系统、同一个版本，但是在接下来可能有几台机器进行了自动升级、有几台机器上某个软件包被自动更新了等等的问题。当服务器产生差异，应用就有可能在一些机器上崩溃。<strong>维护集群软硬件状态的一致性是一个很重要的任务，也是一个棘手的问题</strong>。</p>
<p>用于管理一致性的配置管理工具有不少，比较流行的有puppet、ansible和chef。它们通过由管理员配置的方式，对所有机器进行统一管理，例如安装、删除软件等。</p>
<p>另外一种方式就是采用虚拟化（Virtualization）。虚拟化这个词可能你会陌生，但是虚拟机这个词你肯定熟悉。虚拟机本身就是一种虚拟化技术，它通过用软件模拟硬件环境，让你可以在任何地方运行同一个虚拟机镜像。在Windows 8上，你可以用虚拟机运行两个Ubuntu系统；在Mac上，你也可以运行同样的Ubuntu系统，使用同一个镜像。这是传统的虚拟机虚拟化技术。</p>
<p>Docker是一种轻量级的虚拟化技术。它通过创建镜像，为应用提供一个一致的运行环境。在部署应用的时候，我们不再将应用本身部署到服务器上，而是直接在服务器上运行这个镜像。</p>
<p>我们在本文中不详细聊应用Docker的好处，而是通过一步步操作了解如何部署一个Docker应用。</p>
<h3 id="安装Docker">安装Docker</h3><p>首先需要在你的机器上安装Docker，你可以在自己的Mac、Linux或者Windows下安装。<a href="https://docs.docker.com/engine/installation/mac/" target="_blank" rel="external">Mac安装点这里</a>、<a href="https://docs.docker.com/engine/installation/windows/" target="_blank" rel="external">Windows安装点这里</a>、<a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/" target="_blank" rel="external">Linux安装点这里</a>。</p>
<p>这里以Mac为例，验证安装的方法是在终端里面用<code>docker version</code>命令。若正确安装，你将得到类似下面的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      <span class="number">1.12</span><span class="number">.0</span></span><br><span class="line"> API version:  <span class="number">1.24</span></span><br><span class="line"> Go version:   go1<span class="number">.6</span><span class="number">.3</span></span><br><span class="line"> Git commit:   <span class="number">8</span>eab29e</span><br><span class="line"> Built:        Thu Jul <span class="number">28</span> <span class="number">21</span>:<span class="number">15</span>:<span class="number">28</span> <span class="number">2016</span></span><br><span class="line"> OS/Arch:      darwin/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      <span class="number">1.12</span><span class="number">.0</span></span><br><span class="line"> API version:  <span class="number">1.24</span></span><br><span class="line"> Go version:   go1<span class="number">.6</span><span class="number">.3</span></span><br><span class="line"> Git commit:   <span class="number">8</span>eab29e</span><br><span class="line"> Built:        Thu Jul <span class="number">28</span> <span class="number">21</span>:<span class="number">15</span>:<span class="number">28</span> <span class="number">2016</span></span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
<p>本文是在7月30号写的，可以看到这个版本是新鲜出炉的！</p>
<h3 id="准备源代码">准备源代码</h3><p>我已经在GitHub上面为你准备好了示例项目。登录GitHub后fork<a href="https://github.com/tjwudi/sat-example" target="_blank" rel="external">这个项目（https://github.com/tjwudi/sat-example）</a>，并clone你刚才fork的项目到本地来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:你的用户名/sat-example.git</span><br><span class="line">$ <span class="built_in">cd</span> sat-example</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意不要用下载zip文件或者直接clone原项目的方式，因为在后续流程中我们需要往GitHub推新的tag。</p>
</blockquote>
<p>这是一个由Express.js生成的项目，在安装了Node.js和包管理器npm的前提下，你可以通过下面命令验证它是否能正确运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a>即可看到欢迎页。</p>
<h3 id="发布新的Release">发布新的Release</h3><p>每一个发布到生产环境的Docker镜像都应该对应着源代码仓库的一次发布（Release）。直接在本地开发分支的代码基础上构建Docker镜像是欠妥的。</p>
<p>在GitHub上面发布一个新的Release分成两步。第一步是在<strong>sat-example</strong>的代码仓库里面创建一个tag，tag名称为版本号，然后将其发布到GitHub上。例如这里我们发布一次版本号0.1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="number">0.1</span></span><br><span class="line">$ git push origin master --tags</span><br></pre></td></tr></table></figure>
<p><code>git push</code>带上<code>--tags</code>参数将把本地的tag同步到GitHub上。此时在GitHub的Release标签页里面会看到这个新的tag。</p>
<!-- 1 -->
<p>第二步点击右上方的”Draft a new release”，选择已有的tag 0.1，简单填写一下发布的标题和内容。</p>
<!-- 2 -->
<p>最后点击Publish release发布新的版本。</p>
<!-- 3 -->
<p>在开源代码仓库上发布新的版本是一个常用流程，在日常的开发过程中也会经常用到。</p>
<h3 id="脚本：下载最新的发布">脚本：下载最新的发布</h3><p>在<strong>sat-example</strong>新建一个<strong>docker</strong>文件夹，里面存放构建Docker镜像相关的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir docker</span><br><span class="line">$ touch docker/build-docker</span><br><span class="line">$ chmod +x docker/build-docker</span><br></pre></td></tr></table></figure>
<p>我们新建了文件<strong>docker/build-docker</strong>，这将是一个Bash脚本，并给予它执行权限。今后在构建镜像的时候，只需执行<code>./build-docker</code>即可构建出一个Docker镜像。</p>
<p>脚本每次构建一个Docker镜像的工作流是：</p>
<ol>
<li>用脚本从GitHub上自动下载最新一次发布的源代码压缩包</li>
<li>根据Dockerfile构建Docker镜像</li>
</ol>
<p>在进行第一步之前我们先要定义所需的变量，例如GitHub的代码仓库名等。这样可以在后面的脚本中重用，也方便用到其他项目中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">"Your Github Token: "</span></span><br><span class="line"><span class="built_in">read</span> TOKEN</span><br><span class="line"></span><br><span class="line">REPO=<span class="string">"sat-example"</span></span><br><span class="line">OWNER=<span class="string">"tjwudi"</span> <span class="comment"># 注意将这里换成你的用户名</span></span><br><span class="line">ROOT=$(<span class="built_in">pwd</span>)    <span class="comment"># 工作目录，应为xxx/docker</span></span><br></pre></td></tr></table></figure>
<p><code>TOKEN</code>是GitHub上的Personal access token（PAT），接下来将使用它调用GitHub的API。使用PAT而不使用用户名密码组合是因为现在大部分GitHub账户都开启了双重验证（2-factor authentication），在这个情况下将不能用用户名密码来调用API。</p>
<p>调用GitHub的API获取代码仓库的最新发布。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">gh_curl</span></span>() &#123;</span><br><span class="line">  curl -H <span class="string">"Authorization: token <span class="variable">$TOKEN</span>"</span> \</span><br><span class="line">     <span class="variable">$@</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Getting latest release version ..."</span></span><br><span class="line">gh_curl https://api.github.com/repos/<span class="variable">$OWNER</span>/<span class="variable">$REPO</span>/releases/latest &gt; latest.json</span><br><span class="line">TAG_NAME=`cat latest.json | jq <span class="string">'.tag_name'</span> |  tr <span class="operator">-d</span> <span class="string">'"'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br></pre></td></tr></table></figure>
<p><code>TAG_NAME</code>将是最新一次发布的tag名称。在我们的例子中，你将得到的是<strong>0.1</strong>这个值。接下来将该发布的压缩包下载下来并解压在<code>docker/releases</code>文件夹下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">"Downloading latest release ..."</span></span><br><span class="line">ZIP_FILE=<span class="string">"releases/<span class="variable">$TAG_NAME</span>.zip"</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="string">"releases"</span> ]; <span class="keyword">then</span></span><br><span class="line">  mkdir releases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">wget -q --auth-no-challenge --header=<span class="string">'Accept:application/octet-stream'</span> \</span><br><span class="line">    https://<span class="variable">$TOKEN</span>:@github.com/<span class="variable">$OWNER</span>/<span class="variable">$REPO</span>/archive/<span class="variable">$TAG_NAME</span>.zip \</span><br><span class="line">      -O <span class="variable">$ZIP_FILE</span></span><br><span class="line">rm -rf latest.json</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br></pre></td></tr></table></figure>
<p><strong>docker/releases</strong>文件夹专门用来存放下载下来的发布代码，应该把它加到项目的<strong>.gitignore</strong>文件中去。</p>
<p>将新发布的代码全部解压到<strong>docker/src</strong>下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">"Unzip files ... "</span></span><br><span class="line">unzip -o <span class="variable">$ZIP_FILE</span> <span class="operator">-d</span> releases &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">ORIGIN_SRC=<span class="string">"releases/runny-server-<span class="variable">$TAG_NAME</span>"</span></span><br><span class="line">SRC=<span class="string">"releases/src"</span></span><br><span class="line">rm -rf <span class="variable">$SRC</span></span><br><span class="line">mkdir <span class="variable">$SRC</span></span><br><span class="line">mv <span class="variable">$ORIGIN_SRC</span>/* <span class="variable">$SRC</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br></pre></td></tr></table></figure>
<p>如果你的项目涉及要用构建工具（如grunt和gulp）构建生产环境文件，那么此时就是构建的时候了。在我们的<strong>sat-example</strong>项目中，你不需要做这一步。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$SRC</span></span><br><span class="line">npm install &amp;&amp; bower install</span><br><span class="line">gulp build</span><br></pre></td></tr></table></figure>
<p>最后用<code>docker build</code>命令，构建最新的一个镜像。<code>docker build</code>还依赖于配置文件<strong>Dockerfile</strong>，在下一节中我们会详细描述。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$ROOT</span></span><br><span class="line">docker build -t runny:<span class="variable">$TAG_NAME</span> .</span><br></pre></td></tr></table></figure>
<p>完整的构建脚本如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IMPORTANT: Run this script against /docker directory</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Your Github Token: "</span></span><br><span class="line"><span class="built_in">read</span> TOKEN</span><br><span class="line"></span><br><span class="line">REPO=<span class="string">"sat-example"</span></span><br><span class="line">OWNER=<span class="string">"tjwudi"</span></span><br><span class="line">ROOT=$(<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">gh_curl</span></span>() &#123;</span><br><span class="line">  curl -H <span class="string">"Authorization: token <span class="variable">$TOKEN</span>"</span> \</span><br><span class="line">     <span class="variable">$@</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Getting latest release version ..."</span></span><br><span class="line">gh_curl https://api.github.com/repos/<span class="variable">$OWNER</span>/<span class="variable">$REPO</span>/releases/latest &gt; latest.json</span><br><span class="line">TAG_NAME=`cat latest.json | jq <span class="string">'.tag_name'</span> |  tr <span class="operator">-d</span> <span class="string">'"'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Downloading latest release ..."</span></span><br><span class="line">ZIP_FILE=<span class="string">"releases/<span class="variable">$TAG_NAME</span>.zip"</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="string">"releases"</span> ]; <span class="keyword">then</span></span><br><span class="line">  mkdir releases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">wget -q --auth-no-challenge --header=<span class="string">'Accept:application/octet-stream'</span> \</span><br><span class="line">    https://<span class="variable">$TOKEN</span>:@github.com/<span class="variable">$OWNER</span>/<span class="variable">$REPO</span>/archive/<span class="variable">$TAG_NAME</span>.zip \</span><br><span class="line">      -O <span class="variable">$ZIP_FILE</span></span><br><span class="line">rm -rf latest.json</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Unzip files ... "</span></span><br><span class="line">unzip -o <span class="variable">$ZIP_FILE</span> <span class="operator">-d</span> releases &gt; /dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">ORIGIN_SRC=<span class="string">"releases/runny-server-<span class="variable">$TAG_NAME</span>"</span></span><br><span class="line">SRC=<span class="string">"releases/src"</span></span><br><span class="line">rm -rf <span class="variable">$SRC</span></span><br><span class="line">mkdir <span class="variable">$SRC</span></span><br><span class="line">mv <span class="variable">$ORIGIN_SRC</span>/* <span class="variable">$SRC</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"done"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Build image"</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$ROOT</span></span><br><span class="line">docker build -t runny:<span class="variable">$TAG_NAME</span> .</span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile">Dockerfile</h3><p>Docker根据一个名为Dockerfile的文件构建镜像。当运行<code>docker build</code>命令的时候，Docker会在当前目录下寻找Dockerfile，并根据Dockerfile的指令一步步构建镜像。</p>
<p>在<strong>docker</strong>文件夹下新建一个文件<strong>Dockerfile</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM node:<span class="number">5.12</span><span class="number">.0</span></span><br><span class="line">MAINTAINER Di Wu &lt;i@leapoahead.com&gt;</span><br></pre></td></tr></table></figure>
<p>文件的第一行指定了你要构建的镜像的“基镜像”。你不需要去自己从头构建每一个镜像，从安装新系统，到安装必要的系统软件…… 你只需要指定一个基镜像，那是别人做好的镜像，你在别人的基础上进行修改，就可以构建出自己的镜像了。在这里我们选择的是<code>node:5.12.0</code>作为基镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD</span> <span class="bash">./releases/src /sat-example</span><br><span class="line"></span><span class="built_in">WORKDIR</span> <span class="bash">/sat-example</span></span><br></pre></td></tr></table></figure>
<p><code>ADD</code>是一个Docker指令。<code>ADD &lt;src&gt; &lt;target&gt;</code>将把你本机上的<code>&lt;src&gt;</code>拷贝到镜像里面的<code>&lt;target&gt;</code>。这里我们将之前脚本里面所得到的最新发布的源代码拷贝到镜像中<code>/sat-example</code>文件夹。</p>
<p><code>WORKDIR &lt;workdir&gt;</code>指令指定了在镜像中的工作目录。接下来的所有工作都是基于该目录为默认的根目录进行的。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">npm install --production &amp;&amp; npm install forever -g</span><br><span class="line"></span><span class="built_in">ENV</span> NODE_ENV=production</span><br></pre></td></tr></table></figure>
<p><code>RUN</code>指令在镜像内执行bash命令。我们通过它安装一些在基镜像里面没有的系统软件，或安装依赖项。需要注意的是，<strong>尽量不要在Dockerfile里面构建</strong>。Dockerfile里面的任何一切都只应该是生产环境的，也就是说，不应该存在开发环境采用的依赖项（devDependencies），也不应该存在未经构建的源文件。</p>
<p>我们还安装了<a href="https://github.com/foreverjs/forever" target="_blank" rel="external">forever</a>，用于管理Node应用进程状态，让应用保持运行。</p>
<p><code>ENV</code>指令让我们定义镜像中的环境变量，此处我们将Node的运行环境设置为production（生产环境）。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMD</span> <span class="bash">[<span class="string">"forever"</span>, <span class="string">"start"</span>, <span class="string">"bin/www"</span>]</span><br><span class="line"></span><span class="built_in">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<p><code>CMD</code>指令指定了在镜像启动时所执行的命令。当镜像启动后，将直接运行<code>forever start bin/www</code>启动我们的应用；<code>EXPOSE</code>指令告诉Docker这个镜像将监听TCP 3000端口。</p>
<p>完整的Dockerfile如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> node:<span class="number">5.12</span>.<span class="number">0</span></span><br><span class="line"><span class="built_in">MAINTAINER</span> Di Wu &lt;i@leapoahead.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD</span> <span class="bash">./releases/src /sat-example</span><br><span class="line"></span><span class="built_in">WORKDIR</span> <span class="bash">/sat-example</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">npm install --production &amp;&amp; npm install forever -g</span><br><span class="line"></span><span class="built_in">ENV</span> NODE_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMD</span> <span class="bash">[<span class="string">"forever"</span>, <span class="string">"start"</span>, <span class="string">"bin/www"</span>]</span><br><span class="line"></span><span class="built_in">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3><p>第一部分中我们分步讲解了构建镜像的全过程。其中最重要的一个理念是，每一个Docker镜像都对应一次版本发布，所以我们应该下载获取最新的发布，而不是直接基于本地开发中的源代码构建。</p>
<p>第二部分里面我们将镜像发布到生产环境上并运行，并学习如何管理、监控你的Docker容器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Docker在前几天发布了Mac和Windows的版本，从此Mac用户可以无需安装VirtualBox使用Docker。这给更多对Docker只闻其名但未曾尝试的朋友更方便地动手尝试的机会。本文将带你了解Docker，并一步步使用Docker将一个Node.js应用部署到生产环境中。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[那些我想解决的问题 -- 空闲的优质咖啡店]]></title>
    <link href="http://blog.leapoahead.com/2016/07/01/startup-plans-1/"/>
    <id>http://blog.leapoahead.com/2016/07/01/startup-plans-1/</id>
    <published>2016-07-01T07:43:36.000Z</published>
    <updated>2016-07-01T08:38:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>观察互联网创业圈子有一段时间了。在观察的过程中喜欢结合自己微不足道的技术经验，思考现在有什么样有趣的问题是值得我花时间去解决的、应该用什么样的方式去解决。我所关注的绝大多数是SaaS（软件即服务）领域能解决的问题。</p>
<p>因此我每过一段时间希望将自己前一阵子所在思考的问题分享出来。对于适合我的问题，希望和更多人一起讨论；对于不适合我的问题，希望它们能找到自己的新主人。</p>
<p>今天分享的是该系列的第一个问题。</p>
<h3 id="空闲的优质咖啡店">空闲的优质咖啡店</h3><img src="/2016/07/01/startup-plans-1/1.jpeg" alt="1.jpeg" title="">
<p>我生活在福建厦门，一个美丽的小岛。在这个一百三十多平方公里的小岛上，有着约3000家咖啡店。因此平均每平方公里就约有十几甚至二十多家咖啡店。（<a href="http://tv.xmtv.cn/2015/07/29/VIDE1438178062600746.shtml" target="_blank" rel="external">数据来源</a>）如此大密度的咖啡店布局自然让这一行业有着很强的竞争。尤其随着各种外来大品牌的进入，很多小咖啡店是开得快倒得也快。</p>
<p>我花了将近一个月走访了一些厦门本土藏得比较深的咖啡店。这些的咖啡店存在以下特点：</p>
<ol>
<li>技术专业，比在闹市区的人流如潮的咖啡店普遍要好</li>
<li>顾客稀少，有些老板称自己的店一天最多</li>
<li>环境都还不错，主人对环境的要求高</li>
</ol>
<p>往往就是这样的店让主人有是否继续经营的困惑。有些咖啡店虽说所处地段租金不高，但是稀少的客户源让其依然难以盈利。</p>
<p>有一位店主人提出，他们的店在没人的时候如果能以类似出租的形式出租给一些小团体（例如创业团队、学生团体），并为他们提供租客专享的优惠的话，那么可能可以提高他们的营业额。他声称他愿意为这样的一款软件而付款——帮他招徕团体租客的应用。</p>
<p>将空闲咖啡店“出租”这一个创业点子之前我就有看到了，那是纽约一家咖啡店的策划。他们通过把自己的店面按时段出租给创业团队。它们提供低廉的租金并赠送饮品，对于更多的饮品还提供优惠。</p>
<p>若店家愿意采取这样新颖的商业模式，那么作为SaaS的提供者，我们的软件应该扮演一个中间者的角色。即对接<strong>想要找到空闲的优质咖啡店的团队</strong>和<strong>空闲的优质咖啡店</strong>。可以概括成“Airbnb for teams &amp; great local cafés”。</p>
<p>这是一个需要从两方面去思考的问题，一是店家对该商业模式的态度，二是产品本身的设计。前者需要在产品前期找到至少十家这样的咖啡店愿意加入，而后者则需要一个对设计非常注重的执行团队来解决。</p>
<p>对于这样的一个产品，设计不可谓不重要。产品的受众主要受众将为二三十岁追求逼格的年轻人，因此从需要一个洋气、年轻和关注设计的团队来一同搭建。</p>
<h3 id="LET’S_TALK">LET’S TALK</h3><p>你如果对这个问题感兴趣，希望有深入的探讨的话，欢迎在评论区回复。或者，你可以通过邮件（webmaster@leapoahead.com）联系我。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3><p>观察互联网创业圈子有一段时间了。在观察的过程中喜欢结合自己微不足道的技术经验，思考现在有什么样有趣的问题是值得我花时间去解决的、应该用什么样的方式去解决。我所关注的绝大多数是SaaS（软件即服务）领域能解决的问题。</p>
<p>因此我]]>
    </summary>
    
      <category term="Startup" scheme="http://blog.leapoahead.com/categories/Startup/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[指路Reactive Programming]]></title>
    <link href="http://blog.leapoahead.com/2016/03/02/introduction-to-reactive-programming/"/>
    <id>http://blog.leapoahead.com/2016/03/02/introduction-to-reactive-programming/</id>
    <published>2016-03-02T11:58:21.000Z</published>
    <updated>2016-03-03T01:23:48.000Z</updated>
    <content type="html"><![CDATA[<p>我在工作中采用Reactive Programming（RP）已经有一年了，对于这个“新鲜”的辞藻或许有一些人还不甚熟悉，这里就和大家说说关于RP我的理解。希望在读完本文后，你能够用Reactive Extension进行RP。</p>
<a id="more"></a>
<p>需要说明的是，我实在不知道如何翻译Reactive Programming这个词组，所以在本文中均用RP代替，而不是什么“响应式编程”、“反应式编程”。本文假定你对JavaScript及HTML5有初步的了解，如果有使用过，那么就再好不过了。</p>
<p>让我们首先来想象一个很常见的交互场景。当用户点击一个页面上的按钮，程序开始在后台执行一些工作（例如从网络获取数据）。在获取数据期间，按钮不能再被点击，而会显示成灰色的”disabled”状态。当加载完成后，页面展现数据，而后按钮又可以再次使用。（如下面例子的这个load按钮）</p>
<p><a class="jsbin-embed" href="http://jsbin.com/yaneve/embed?js,output" target="_blank" rel="external">JS Bin on jsbin.com</a></p>
<p>在这里我使用jQuery编写了按钮的逻辑，具体的代码是这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'.load'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loading = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> $btn = $(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">  $btn.prop(<span class="string">'disabled'</span>, loading);</span><br><span class="line">  $btn.text(<span class="string">'Loading ...'</span>);</span><br><span class="line">  </span><br><span class="line">  $.getJSON(<span class="string">'https://www.reddit.com/r/cats.json'</span>)</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      loading = <span class="literal">false</span>;</span><br><span class="line">      $btn.prop(<span class="string">'disabled'</span>, loading);</span><br><span class="line">      $btn.text(<span class="string">'Load'</span>);</span><br><span class="line">    </span><br><span class="line">      $(<span class="string">'#result'</span>).text(<span class="string">"Got "</span> + data.data.children.length + <span class="string">" results"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对应的HTML：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="type">class</span>=<span class="string">"load"</span>&gt;Load&lt;/button&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"result"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>不知道你有没有注意到，在这里<code>loading</code>变量其实是完全可以不用存在的。而我写出<code>loading</code>变量，就是为了抓住你的眼球。<code>loading</code>代表的是一个状态，意思是“我的程序现在有没有在后台加载程序”。</p>
<p>另外还有几个不是很明显的状态。比如按钮的<code>disabled</code>状态（由<code>$btn.prop(&#39;disabled&#39;)</code>获得），以及按钮的文字。在加载的时候，也就是<code>loading === true</code>的时候，按钮的<code>disable</code>状态会是<code>true</code>，而文字会是<code>Loading ...</code>；在不加载的时候，<code>loading === false</code>成立，按钮的<code>disabled</code>状态就应该为<code>false</code>，而文字就是<code>Load</code>。</p>
<p>现在让我们用静态的图来描述用户点击一次按钮的过程。</p>
<img src="/2016/03/02/introduction-to-reactive-programming/1.png" alt="用户点击一次按钮的过程" title="用户点击一次按钮的过程">
<p>如果用户点击很多次的按钮的话，那么<code>loading</code>的值的变化将是这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loading: <span class="literal">false</span> -&gt; <span class="literal">true</span> -&gt; <span class="literal">false</span> -&gt; <span class="literal">true</span> -&gt; <span class="literal">false</span> -&gt; <span class="literal">true</span> -&gt; ...</span><br></pre></td></tr></table></figure>
<p>类似像<code>loading</code>这样的<strong>状态（state）</strong>在应用程序中随处可见，而且其值的变化可以不局限于两个值。举个栗子，假如我们现在设计微博的前端，一条微博的JSON数据形式如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aWeibo = &#123;</span><br><span class="line">    user: <span class="number">1</span>,</span><br><span class="line">    text: <span class="string">'我今天好高兴啊！'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外有一个<code>weiboList</code>数组，存储当前用户所看到的微博。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var weiboList = [</span><br><span class="line">    &#123;<span class="string">user:</span> <span class="number">1</span>, <span class="string">text:</span> <span class="string">'今天又出去玩了'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">user:</span> <span class="number">2</span>, <span class="string">text:</span> <span class="string">'人有多大胆，地有多大产！'</span>&#125;，</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这当然是个极度精简的模型了，真实的微博应用一定比这个复杂许多。但是有一个和<code>loading</code>状态很类似的就是<code>weiboList</code>，因为我们都知道每过一段时间微博就会自动刷新，也就是说<code>weiboList</code>也在一直经历着变化。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">weiboList</span>: [一些微博] -&gt; [旧的微博，和一些新的微博] -&gt; [更多的微博] -&gt; ...</span><br></pre></td></tr></table></figure>
<p>再次强调，无论是<code>weiboList</code>还是<code>loading</code>，它们都是应用程序的状态。上面的用箭头组成的示意图仅仅是我们对状态变化的一种展现形式（或者说建模）。然而，我们其实还可以用更加简单的模型来表现它，而这个模型我们都熟悉 —— 数组。</p>
<h3 id="如果它们都只是数组">如果它们都只是数组</h3><p>如果说<code>loading</code>变化的过程就是一个数组，那么不妨把它写作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadingProcess = [<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, ...]</span><br></pre></td></tr></table></figure>
<p>为了表现出这是一个过程，我们将其重新命名为<code>loadingProcess</code>。不过它没有什么不同，它是一个数组。而且我们还可以注意到，按钮的<code>disabled</code>状态的变化过程和<code>loadingProcess</code>的变化过程是一模一样的。我们将<code>disabled</code>的变化过程命名为<code>disabledProcess</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> disabledProcess = [<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, ...]</span><br></pre></td></tr></table></figure>
<p>那么如果将<code>loadingProcess</code>做下面的处理，我们将得到什么呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textProcess = loadingProcess.map(<span class="function"><span class="keyword">function</span>(<span class="params">loading</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loading ? <span class="string">"Loading ..."</span> : <span class="string">"Load"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们得到的将是按钮上文字的状态变化过程，也就是<code>$btn.text()</code>的值。我们将其命名为<code>textProcess</code>。在有了<code>textProcess</code>和<code>disabledProcess</code>之后，就可以直接对UI进行更新。在这里，我们不再需要使用到<code>loadingProcess</code>了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">disabledProcess.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">disabled</span>) </span>&#123;</span><br><span class="line">    $btn.prop(<span class="string">'disabled'</span>, disabled);</span><br><span class="line">&#125;);</span><br><span class="line">textProcess.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    $btn.text(text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个变换的过程看起来就像下图。</p>
<img src="/2016/03/02/introduction-to-reactive-programming/2.png" alt="变换过程1" title="变换过程1">
<p>在YY了那么久之后，你可能会说，不对啊！状态的变化是<strong>一段时间内</strong>发生的事情，在程序一开始怎么可能就知道之后的全部状态，并全部放到一个数组里面呢？是的，我们在之前刻意省略掉了一个重要的元素，也就是<strong>时间（time）</strong>。</p>
<h3 id="时间都去哪儿啦？">时间都去哪儿啦？</h3><p><code>loadingProcess</code>是如何得出的？当用户触发按钮的点击事件的时候，<code>loadingProcess</code>会被置为<code>false</code>；而当HTTP请求完成的时候，我们将其置为<code>true</code>。在这里，用户触发点击事件，和HTTP请求完成都是一个需要时间的过程。用户的两次点击之间必定要有时间，就像这样：</p>
<blockquote>
<p>clickEvent … clickEvent …… clickEvent ….. clickEvent</p>
</blockquote>
<p>两个clickEvent之间一个点我们假设代表一秒钟，用户点击的事件之间是由长度不同的时间间隔开的。</p>
<p>如果我们再尝试用刚才的方法，把click事件表示成一个数组，就会觉得特别的古怪：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> clickEventProcess</span> = [ clickEvent, clickEvent, clickEvent, clickEvent, clickEvent, ... ]</span><br></pre></td></tr></table></figure>
<p>你会想，古怪之处在于，这里没了时间的概念。其实不一定是这样的。你觉得这里少了时间，只是因为你被我刚才的例子所迷惑了。你的脑袋里面可能是在想下面的这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码A</span></span><br><span class="line">clickEventProcess.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">clickEvent</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果是下面这段代码，我相信你再熟悉不过了，你还会觉得奇怪吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码B</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.load'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">clickEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>代码A中，我们所看到的是迭代器模式（Iterative Pattern）。所谓迭代器模式是对遍历一个集合的算法所进行的抽象。对于一个数组、一个二叉树和一个链表的遍历算法各不相同，但我都可以用统一的一个接口来获取遍历的结果。<code>forEach</code>就是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">元素</span>) </span>&#123; <span class="comment">/* ... */</span>&#125;);</span><br><span class="line">二叉树.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">元素</span>) </span>&#123; <span class="comment">/* ... */</span>&#125;);</span><br><span class="line">链表.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">元素</span>) </span>&#123; <span class="comment">/* ... */</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然每个<code>forEach</code>的实现方式一定不同，但是只要接口（即<code>forEach</code>这个名字以及<code>元素</code>这个参数）一致，我就可以遍历它们之中任何的一个，不管是数组、二叉树还是二郎神。只要它们都是实现了<code>forEach</code>的集合。</p>
<p>下面这句话希望你仔细品味：</p>
<blockquote>
<p>迭代器模式的一个最大的特点就是，数据是由你向集合索要过来的。</p>
</blockquote>
<p>在使用迭代器的时候，我们其实就是在向集合要数据，而且每次都企图一次性要完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这就好像在对集合说，你把那五个数字给我吧，快点儿，一个接一个一次性给完。在生活中，就好像蛋糕店的服务员帮你切蛋糕一样。你总是在和服务员说，麻烦你再给我下一块，再给我下一块……</p>
<img src="/2016/03/02/introduction-to-reactive-programming/3.png" alt="切蛋糕-迭代器" title="切蛋糕-迭代器">
<p>而代码B是截然相反的。在代码B中，我们是在等待着数据被<strong>推送</strong>过来。又拿切蛋糕为例，这次就好像是你一言不发，而服务员一直跟你说，“这块切好了，给你！”。</p>
<img src="/2016/03/02/introduction-to-reactive-programming/4.png" alt="切蛋糕-推送" title="切蛋糕-推送">
<p>如果你对设计模式熟悉的话，你应该知道代码B的模式叫做观察者模式（Observer Pattern）。所谓观察者模式，就是你观察集合，当集合告诉你它有元素要给你的时候，你就可以拿到元素。<code>addEventListener</code>本身就是一个很好的观察者模式的例子。</p>
<p>在切蛋糕的例子中，当你双目注视的服务员，耳朵竖得高高的，你就是在对服务员进行观察。每当服务员告诉你，有一块新的蛋糕切好了，你就过去拿。</p>
<h3 id="迭代器和观察者的对立和统一">迭代器和观察者的对立和统一</h3><p>迭代器模式和观察者模式本质上是对称的。它们相同的地方在于：</p>
<ol>
<li>都是对集合的遍历（都是那块大蛋糕）</li>
<li>每次都只获得一个元素</li>
</ol>
<p>他们完全相反的地方只有一个：迭代器模式是你主动去要数据，而观察者模式是数据的提供方（切蛋糕的服务员）把数据推给你。他们其实完全可以用同样的接口来实现，例如前面的例子中的代码A，我们来回顾一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码A</span></span><br><span class="line">clickEventProcess.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">clickEvent</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于代码B，我们可以进行如下的改写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码B</span></span><br><span class="line">clickEventProcess.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._fn = fn; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clickEventProcess.onNext = <span class="function"><span class="keyword">function</span>(<span class="params">clickEvent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._fn(clickEvent);  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.load'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">clickEvent</span>) </span>&#123;</span><br><span class="line">    clickEventProcess.onNext(clickEvent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">clickEventProcess.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">clickEvent</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们解读一下修改过的代码B。</p>
<ol>
<li><code>clickEventProcess.forEach</code>: 它接受一个回调函数作为参数，并存储在<code>this._fn</code>里面。这是为了将来在<code>clickEventProcess.onNext</code>里面调用</li>
<li>当clickEvent触发的时候，调用<code>clickEventProcess.onNext(clickEvent)</code>，将<code>clickEvent</code>传给了<code>clickEventProcess</code></li>
<li><code>clickEventProcess.onNext</code>将<code>clickEvent</code>传给了<code>this._fn</code>，也就是之前我们所存储的回调函数</li>
<li>回调函数正确地接收到新的点击事件</li>
</ol>
<p>来看看现在发生了什么……迭代器模式和观察者模式用了同样的接口（API）实现了！因为，它们本质上就是对称的，能用同样的API将两件原本对称的事物给统一起来，这是可以做到的。</p>
<p>迭代器模式，英文叫做Iterative，由你去迭代数据；而观察者模式，要求你对数据来源的事件做出反应（react），所以其实也可以称作是Reactive（能做出反应的）。Iterative和Reactive，互相对称，相爱不相杀。</p>
<blockquote>
<p>话外音：在这里我没有明确提及，实际上在观察者模式中数据就是以流（stream）的形式出现。而所谓数组，不过就是无需等待，马上就可以获得所有元素的流而已。从流的角度来理解Iterative和Reactive的对称性也可以，这里我们不多加阐述。</p>
</blockquote>
<h3 id="Reactive_Extension">Reactive Extension</h3><p>上面代码B中我们最后获得了一个新的<code>clickEventProcess</code>，它不是一个真正意义上的集合，却被我们抽象成了一个集合，一个被时间所间隔开的集合。 <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">Rx.js，也称作Reactive Extension</a>提供给了抽象出这样集合的能力，它把这种集合命名为<code>Observable</code>（可观察的）。</p>
<p>添加Rx.js及其插件Rx-DOM.js。我们需要Rx-DOM.js，因为它提供网络通讯相关的Observable抽象，稍后我们就会看到。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdn.rawgit.com/Reactive-Extensions/RxJS/master/dist/rx.all.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdn.rawgit.com/Reactive-Extensions/RxJS-DOM/master/dist/rx.dom.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只需要很简单的一句工厂函数（factory method）就可以将鼠标点击的事件抽象成一个<code>Observable</code>。Rx.js提供一个全局对象<code>Rx</code>，<code>Rx.Observable</code>就是Observable的类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadButton = <span class="built_in">document</span>.querySelector(<span class="string">'.load'</span>);</span><br><span class="line"><span class="keyword">var</span> resultPanel = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> click$ = Rx.Observable.fromEvent(loadButton, <span class="string">'click'</span>);</span><br></pre></td></tr></table></figure>
<p><code>click$</code>就是前面的<code>clickEventProcess</code>，在这里我们将所有的Observable变量名结尾都添加<code>$</code>。点击事件是像下面这样子的：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">[</span>click <span class="attribute">...</span> click <span class="attribute">...</span><span class="attribute">...</span><span class="built_in">.. </span>click <span class="built_in">.. </span>click <span class="attribute">...</span><span class="built_in">.. </span>click <span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="built_in">.</span><span class="preprocessor">]</span><span class="markup"></span></span><br></pre></td></tr></table></figure>
<p>每个点击事件后应该发起一个网络请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response$$ = click$.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 为了不处理跨域问题，这里换了个地址，返回和前面是一样的</span></span><br><span class="line">   <span class="keyword">return</span> Rx.DOM.get(<span class="string">'http://output.jsbin.com/tafulo.json'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Rx.DOM.ajax.get</code>会发起HTTP GET请求，并返回响应（Response）的Observable。因为每次请求只会有一个响应，所以响应的Observable实际上只会有一个元素。它将会是这样的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...[.....response].......[........response]......[....response]...........[....response]......[....response]]</span><br></pre></td></tr></table></figure>
<p>由于这是Observable的Observable，就好像二维数组一样，所以在变量名末尾是<code>$$</code>。 若将click$和response$$的对应关系勾勒出来，会更加清晰。</p>
<img src="/2016/03/02/introduction-to-reactive-programming/5.png" alt="5.png" title="">
<p>然而，我们更希望的是直接获得Response的Observble，而不是Response的Observble的Observble。Rx.js提供了<code>.flatMap</code>方法，可以将二维的Observable“摊平”成一维。你可以参考<a href="http://underscorejs.org/#flatten" target="_blank" rel="external">underscore.js里面的<code>flatten</code>方法</a>，只不过它是将普通数组摊平，而非将Observable摊平。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response$ = click$.flatMap(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Rx.DOM.get(<span class="string">'http://output.jsbin.com/tafulo.json'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<img src="/2016/03/02/introduction-to-reactive-programming/6.png" alt="6.png" title="">
<p>对于每一个click事件，我们都想将<code>loading</code>置为<code>true</code>；而对于每次HTTP请求返回，则置为<code>false</code>。于是，我们可以将<code>click$</code>映射成一个纯粹的只含有<code>true</code>的Observable，但其每个<code>true</code>到达的事件都和点击事件到达的时间一样；对于<code>response$</code>，同样，将其映射呈只含有<code>false</code>的Observable。最后，我们将两个Observable结合在一起（用<code>Rx.Observable.merge</code>），最终就可以形成<code>loading$</code>，也就是刚才我们的<code>loadingProcess</code>。</p>
<p>此外，<code>$loading</code>还应有一个初始值，可以用<code>startWith</code>方法来指定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loading$ = Rx.Observable.merge(</span><br><span class="line">    click$.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;),</span><br><span class="line">    response$.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;)</span><br><span class="line">).startWith(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>整个结合的过程如图所示</p>
<img src="/2016/03/02/introduction-to-reactive-programming/7.png" alt="7.png" title="">
<p>有了<code>loading$</code>之后，我们很快就能得出刚才我们所想要的<code>textProcess</code>和<code>enabledProcess</code>。<code>enabledProcess</code>和<code>loading$</code>是一致的，就无需再生成，只要生成<code>textProcess</code>即可（命名为<code>text$</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text$ = loading$.map(<span class="function"><span class="keyword">function</span> (<span class="params">loading</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loading ? <span class="string">'Loading ...'</span> : <span class="string">'Load'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Rx.js中没有<code>forEach</code>方法，但有一个更好名字的方法，和<code>forEach</code>效用一样，叫做<code>subscribe</code>。这样我们就可以更新按钮的样式了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">text$.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  $loadButton.text(text);</span><br><span class="line">&#125;);</span><br><span class="line">loading$.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">loading</span>) </span>&#123;</span><br><span class="line">  $loadButton.prop(<span class="string">'disabled'</span>, loading);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response$ 还可以拿来更新#result的内容</span></span><br><span class="line">response$.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  $resultPanel.text(<span class="string">'Got '</span> + <span class="built_in">JSON</span>.parse(data.response).data.children.length + <span class="string">' items'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就用完全Reactive的方式重构了之前我们的例子。</p>
<p><a class="jsbin-embed" href="http://jsbin.com/wurite/embed?html,js,output" target="_blank" rel="external">JS Bin on jsbin.com</a></p>
<p>在我们重构后的方案中，消灭了所有的状态。状态都被Observable抽象了出去。于是，这样的代码如果放在一个函数里面，这个函数将是没有副作用的纯函数。关于纯函数、函数式编程，可以阅读我的文章<a href="http://blog.leapoahead.com/2015/09/19/function-as-first-class-citizen/">《“函数是一等公民”背后的含义》</a>。</p>
<h3 id="总结">总结</h3><p>本文从应用的角度入手解释了Reactive Programming的思路。Observable作为对状态的抽象，统一了Iterative和Reactive，淡化了两者之间的边界。当然，最大的好处就是我们用抽象的形式将烦人的状态赶出了视野，取而代之的是可组合的、可变换的Observable。</p>
<p>事物之间的对立统一通常很难找到。实际上，即使是在《设计模式》这本书中，作者们也未曾看到迭代器模式和观察者模式之间存在的对称关系。在UI设计领域，我们更多地和用户驱动、通信驱动出来的事件打交道，这才促成了这两个模式的合并。</p>
<script src="http://static.jsbin.com/js/embed.min.js?3.35.9"></script>
]]></content>
    <summary type="html">
    <![CDATA[<p>我在工作中采用Reactive Programming（RP）已经有一年了，对于这个“新鲜”的辞藻或许有一些人还不甚熟悉，这里就和大家说说关于RP我的理解。希望在读完本文后，你能够用Reactive Extension进行RP。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《必然》—— 对变革如数家珍]]></title>
    <link href="http://blog.leapoahead.com/2016/02/27/book-of-2016-the-inevitable/"/>
    <id>http://blog.leapoahead.com/2016/02/27/book-of-2016-the-inevitable/</id>
    <published>2016-02-27T01:52:04.000Z</published>
    <updated>2016-02-27T02:48:21.000Z</updated>
    <content type="html"><![CDATA[<p>我曾和别人讨论，Google、Facebook等科技巨人之后，下一家革命性的公司会是做什么的？我还问过Google前员工，“你觉得Google能活几年”？</p>
<a id="more"></a>
<p>科技界不会有下一个Google，也不会有下一个Facebook。这两家公司都已经在各自开辟的领域做到了世界第一，想要超越它们，你必须做出比他们现有产品好出许多的产品，这是近乎不可能的事情了。所以我们的关注点应该就放在，下一个和现有巨头完全不同的巨头会是怎么样的。</p>
<p>互联网带给我们的众多的变革，却少有人能如数家珍地罗列出来。最多也就是在微信朋友圈看些零零散散的文章，夸一夸互联网+，扯一扯新经济转型……而Kevin Kelly在他的著作《必然》之中却做到了对现在互联网科技圈子庖丁解牛。</p>
<p>在书中谈到知化（Cognifying）的时候，我不禁在思索我们这些工程师未来的职业道路。在人工智能发展的初期，我们都骄傲地认为人工智能是受我们（工程师）所控制的，毕竟其源代码是由我们编写出来的。尽管在其他领域，人工智能驱动的机器人一直在颠覆一些人现有的工作。</p>
<p>注意到这里我说的是<strong>颠覆</strong>，而非取代。机器无法替代人类，因为人类不是生活在二进制世界中的。机器擅长从二进制的数据中学习，通过数学模型快速地学习。而人类不是这样的，我们通过知性的记忆来进行学习。但也正因为这样，很多工作，例如清洁、纺织、食品生产等很容易从过往数据总结规律的事情，很快就能被我们的机器所学会。它们可以帮助我们更高效的解决问题，但不会直接出面帮你解决问题。</p>
<p>永远记住，电脑是很笨的。它们所知道的什么东西都是我们主动教给他们的，有时候教错了，这个锅还得我们来背。扯远了。</p>
<p>那么它可不可能大规模地颠覆软件工程师的工作呢？答案是可能。有一件工程师们心知肚明的事情，那就是我们其实很多时候都在做一些无谓的重复劳动。这些重复劳动很多是机器人可以学习、替代的。没有理由机器人完全无法理解我们在编写的程序，它自己本身就来自那个世界。</p>
<p>企业本身会很乐意人工智能驱动的机器人（虽然它不一定要是真的拥有铝合金外壳的机器人的形式）出现，毕竟现在养一个工程师真的是太贵了。工程师每天如果坐在办公室里面八个小时，其中能够高效工作的或许只有三到四个小时。好的工程师总是会花时间学习、沟通的，而他们真正在高效工作，应当是在不假思索的编码的过程。如果把敲键盘的事情大部分交给自动化的流程完成，或者，由工程师口述（通过语音输入），然后由人工智能生成代码，那么效率将有大大的提升。</p>
<p>我相信很多基础的工程职位会被人工智能替换掉，这在建筑设计业、公共运输业都已经在发生，在软件业也将会发生。想到这里，我不禁双腿一颤，赶快左手捧起一本《机器学习》、右手捧起一本《电工基础》，希望未来有机器人要抢我饭碗的时候，我至少还有机会可以想想办法把它干掉……</p>
<p>说到口述，这个尝试其实已经可以开始了。现在的语音输入技术完全能够让一个人在五分钟内打出一篇五千字的文章（取决于口语水平）。未来，我们可能不止于语音输入，我们还会进入脑电波输入的时代。只需要想一想，屏幕上就会出现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'JavaScript is the best programming language, if, PHP is not here.'</span>);</span><br></pre></td></tr></table></figure>
<p>一切看起来都是那么幸福。</p>
<p>推荐这本《必然》给大家，书中有对科技行业的十一个方向的洞悉，想必至少有一个你会感兴趣。</p>
<img src="/2016/02/27/book-of-2016-the-inevitable/the_inevitable.jpg" alt="The Inevitable" title="The Inevitable">]]></content>
    <summary type="html">
    <![CDATA[<p>我曾和别人讨论，Google、Facebook等科技巨人之后，下一家革命性的公司会是做什么的？我还问过Google前员工，“你觉得Google能活几年”？</p>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://blog.leapoahead.com/categories/reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Hooked》 - 用户行为操纵的技术]]></title>
    <link href="http://blog.leapoahead.com/2016/02/13/book-of-2016-hooked-how-to-build-habit-forming-products/"/>
    <id>http://blog.leapoahead.com/2016/02/13/book-of-2016-hooked-how-to-build-habit-forming-products/</id>
    <published>2016-02-13T04:13:29.000Z</published>
    <updated>2016-02-13T05:01:55.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Start-ups are grueling and only the most fortunate persevere before finding success. If you only build for fame or fortune, you will likely find neither. Build for meaning, though, and you can’t go wrong. （创业是极其艰辛的，只有那些最幸运的人才能在找到成功之前一直坚持下去。如果你是为了追求财富和名望去创业，那么你几乎是两者都无法得到的。反之，为了一个使命的意义去奋斗，那就没错了）</p>
</blockquote>
<a id="more"></a>
<p>大过年的，除了吃和睡之外，看本书才能平衡一下心理。作为2016看的第二本书，《Hooked: How to Build Habit-forming Products》介绍了构建操纵用户行为习惯的模型——Hook Model。中文名应该可以叫做《过瘾！—— 如何操纵用户的行为习惯》，看起来有点像控制狂写的书。</p>
<img src="/2016/02/13/book-of-2016-hooked-how-to-build-habit-forming-products/2.png" alt="Push Notification 《Hooked: How to Build Habit-forming Products》" title="Push Notification 《Hooked: How to Build Habit-forming Products》">
<p>整个Hook Model由四个阶段构成，分别是：</p>
<ul>
<li>Trigger（触发）</li>
<li>Action（行动）</li>
<li>Reward（回馈）</li>
<li>Investment（投资）</li>
</ul>
<p>书中举了不少例子供参考，例如Facebook、Twitter、Tinder（国外的交友App）和Pinterest。通过结合例子介绍Hook Model，让人深深觉得自己处于一个被别人深深套牢的境地。边看例子变回想，有时候都觉得要冒冷汗，心里直想，“尼玛，原来这个功能是为了让我干这个事”！</p>
<p>其中最有趣的部分是Trigger和Reward。</p>
<h3 id="Trigger">Trigger</h3><p>Trigger（触发）指的是触发用户进行某一行为的诱因。Trigger分为Internal Trigger（内部触发）和External Trigger（外部触发）。</p>
<p>外部触发是作为用户能够见到的，应用用于引导用户行为的表现。例如，推送通知就是一个很经典的外部触发。当用户看到一个自己感兴趣的推送通知，他就会打开这个推动通知，并进入这个应用进行阅读等操作。书中外部触发分为四类：</p>
<ol>
<li>Paid Triggers （付费渠道）</li>
<li>Earned Triggers （公共关系）</li>
<li>Relationship Triggers （口口相传）</li>
<li>Owned Triggers （应用内自建的功能）</li>
</ol>
<img src="/2016/02/13/book-of-2016-hooked-how-to-build-habit-forming-products/push-notification.png" alt="Push Notification" title="Push Notification">
<p>（本文图片均来源于网络，不再注明）</p>
<p>而内部触发，从我的理解来看，就是应用给用户的印象与用户当前需求的<strong>契合度</strong>。当用户认为这个应用提供的能力能够解决（或舒缓）他目前的需求，那么他就会受到鼓舞，从而使用这个应用。</p>
<h3 id="Reward">Reward</h3><p>讲Reward的章节全名叫做Variable Reward，核心观点是：</p>
<blockquote>
<p>给予用户的反馈应该是多变的。当用户习惯了同样的一种反馈之后，慢慢就会失去对这个产品的依赖。</p>
</blockquote>
<p>互联网产品设计是一个Infinite Loop，那些广为人知的应用没有一个不是每天都在发生变化的。而变化的最重要的一个环节就是用户反馈的变化。就拿大家都在用的淘宝而言，其核心功能——网购，其实一直都没有变化。但是它所推出的各类促销活动、各种游戏玩法和奖励时时刻刻都在变化。造就一个高用户粘性的产品，靠的不仅仅是最开始那个核心的构想，还有之后不断的创新和变革。</p>
<p>书中将用户反馈分为三种，Reward of the tribe、Reward of the hunt和Reward of the self。其中最强大的一种Reward，我认为应当是Reward of the tribe。Tribe是团体、部落的意思，Reward of the tribe指的主要是社会认同的反馈。</p>
<p>仔细想想为什么很多人喜欢用微信朋友圈，在很多时候，大家实际上期待的是来自自己所在的圈子的一种认同。今天我多读了一本书了，写一篇博客分享给大家，就会期望我所在的圈子给出反馈和鼓励；吃饭之前先拍照，拍照之后分享朋友圈，然后再动筷子……这些都是寻求社会认同，是非常正常也很普遍的事情。然而正是对社会认同感的追求，才造就了今天的微博、微信。</p>
<h3 id="Morality（道德）">Morality（道德）</h3><p>介绍了整个Hook Model之后，作者在整本书最后还介绍了关于操纵用户行为的道德问题。不得不说全书介绍了非常多操纵用户行为的技巧，这些技巧能够帮助你的用户更多、更好地使用你的产品，也可能会对用户的生活产生负面影响。</p>
<p>关于操纵用户行为的道德，其中最为受关注的就是“上瘾”（addicted）的问题。例如，单就用户粘性而言，一些知名游戏的用户粘性明显就很高，甚至到了让人废寝忘食的上瘾地步。如何平衡“提高用户粘性”和“防止用户上瘾”之间做出权衡，是整个操纵用户行为技术的道德问题的核心。</p>
<p>总体而言，这本书是一本从心理学、用户行为、交互设计等多个角度出发，探讨用户行为操作的好书。它适合任何人阅读，无论是一个商业人事、产品设计师、交互设计师还是软件工程师，相信都能从中得到一些产品设计相关的启发。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Start-ups are grueling and only the most fortunate persevere before finding success. If you only build for fame or fortune, you will likely find neither. Build for meaning, though, and you can’t go wrong. （创业是极其艰辛的，只有那些最幸运的人才能在找到成功之前一直坚持下去。如果你是为了追求财富和名望去创业，那么你几乎是两者都无法得到的。反之，为了一个使命的意义去奋斗，那就没错了）</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://blog.leapoahead.com/categories/reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《蔡康永的说话之道》—— 成人的说话法则]]></title>
    <link href="http://blog.leapoahead.com/2016/01/23/book-of-2016-caikangyong/"/>
    <id>http://blog.leapoahead.com/2016/01/23/book-of-2016-caikangyong/</id>
    <published>2016-01-23T05:45:21.000Z</published>
    <updated>2016-01-23T06:50:55.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>练习关心别人，而且表现出你的关心，我觉得是非常值得的，因为你生命中必须有你最在乎的人，你才会活得有滋味。 —— 蔡康永的说话之道</p>
</blockquote>
<a id="more"></a>
<p>2016的年初，回到上海。回来第二天就约了朋友Y到他的新公司参观，坐落在上海城中心。Y约我去主要是要向我咨询一些软件开发相关的事宜，包括一些成本估算、程式结构的设计和进度的规划。他们公司其实自己也有一个全职的工程师GG，Y告诉我他觉得这个GG不太靠谱，所以“请”我来一起聊聊，验证下GG的一些工作。而我呢，其实只是抱着和朋友见面聊天的心态。我不是什么经验丰富的工程师，只是希望能帮上忙。</p>
<p>谈话结束后去吃饭的路上，我和Y说，其实我觉得GG的问题不是在专业知识上，而是在说话上很有问题，所以Y会觉得GG不靠谱。他在别人商量事情的时候喜欢插嘴，他会极力地为自己当下觉得正确的方案辩护。而且在别人讨论其他的方案的时候，他经常自己小声（但别人能听到）地嘀咕自己的方案的优越。</p>
<p>“（小声）哎呀，这样我肯定要多花好久时间的吧”</p>
<p>“（小声）哎呀…哎，那这样我的框架就白写了，浪费了一个月呢”</p>
<p>在吃饭的时候，GG依然保持着他的风格。当别人在聊故事的时候，他很喜欢硬插进来他自己的一些（根本就算不上见解）的见解。譬如，我们在聊一个供暖行业的商业模式，将自家空调装到平常百姓家，然后邀请这些装了空调的家庭变成线下体验店。我当时就质疑这样做是否会破坏整个品牌的一致性，大家也很乐意讨论这个话题。而GG却在旁边一直重复，“这都是风险管理的问题，像我们软件行业……”，我默默地掐着手指算，这句话他重复了六遍。</p>
<p>显然，大家都对他想把话题转移到软件行业很不感兴趣。这真的是因为软件行业没有供暖行业有话聊吗？当然不是。谁会愿意和一个说话带着刺，每一句里面都带着“我”的人聊天呢？</p>
<p>而Y和我的另一个好朋友H，他们两个就是很聊得来的人。当天晚上我们三个人在宾馆里面聊到了凌晨四点半，从未来的职业规划、互联网和供暖行业结合聊到学校里面的各类趣事、女生的行为习惯、美国的蠢货总统候选人……虽然长时间的聊天让身体会疲惫，但是三个能互相欣赏的人聊天会让人有从内而外的舒服。很担心在大学以后就很难遇到这种能分点列清观点与你侃侃而谈的朋友出现了。</p>
<p>对那个晚上印象深刻，是因为恰好最近读完了《蔡康永的说话之道》。蔡康永是台湾的著名节目主持人，主持过很出名的对话类节目《康熙来了》。“说话之道”这本书有趣的地方在于，它被分为了四十个对成年人说话的小建议，这样要让自己对号入座是很容易的。每次读完一个小故事，你就会抬起头来发呆五秒钟，想着，“嗯，我当时真的是犯了这条大忌讳，现在想起来那个听到我这句话的人应该当时心理阴影面积是无穷大吧……”</p>
<img src="/2016/01/23/book-of-2016-caikangyong/1.jpg" alt="蔡康永的说话之道" title="蔡康永的说话之道">
<p>在读这本书的两周多时间里，我一直拿着身边的人做实验。当天H和Y实际上就是被我做了一晚上试验品，毕竟我们做计算机设计的人最注重反复锻炼。</p>
<blockquote>
<p>美国有个调查，说一般人最喜欢的名字，是自己姓名里的字。我不知道这样的调查结果，是否也适合中文姓名？但只要你想一下，你浏览街上招牌、翻阅报纸杂志时，会不会特别被自己的名字里的字吸引？如果会，就表示这个调查结果原则上是成立的人。这么喜欢自己的名字，当别人给你写电子邮件、跟你讲电话时，如果三不五十提起你的名字，你专心而且认同的程度，多会因此大大提高！<br>……<br>下次，当你贪图方便，想按一个键就发出一百则罐头简讯，向朋友贺节的时候，想想对方的感受，想想你这么做真的是在巩固友谊吗？还是在增加彼此的冷漠，同时增加电信业者的营收？ —— 蔡康永的说话之道</p>
</blockquote>
<p>“罐头简讯”的意思就是群发短信。在节日里面，朋友之间互相发送微信、传递微信红包，深层的目的一般都是表达“虽然见不到你，但是我希望通过这则短信告诉你，我还记得你这个朋友，祝我们友谊地久天长”。这样的大前提是，要让对方感觉到这句话是对你说的。当校长站在毕业典礼台上说，“我会记得你们每一个同学的音容笑貌”的时候，你真的相信吗？真的记得住的人，当然是天天和你朝夕相处的同班，而不是那些发言人们。</p>
<p>写信之所以会比发微信温暖，也是因为你会在信封上诚诚恳恳地写下对方的名字，而且要亲自到邮局去投递。</p>
<blockquote>
<p>演讲的人，设身处地的站在台下观众的立场想，是最有用的原则。他们是被学校逼着，在寒风中站在户外听你演讲的应届毕业生吗？他们是一群刚吃完中饭、昏昏欲睡的企业家吗？是一群比较爱听八卦、但迫于社交原因才来听严肃演讲的贵妇？还是一群被病痛所苦的病人？<br>……<br>不管他是自愿花钱买票、或者是被老师老板逼着来听你演讲。只要你体谅他的疲劳，给他一些乐趣，以及两到三样有用的讯息，他就会觉得你是个非常好的演讲者，下次还愿意听你演讲。 —— 蔡康永的说话之道</p>
</blockquote>
<p>我其实很爱好演讲、讲课。原因是在准备课程的过程中，自身也能学到、总结出很多有意思的东西。我之前把很多的精力放在了自己的愉悦上，可我很少想过的是，为什么听我的课的人有些会昏昏欲睡？我会用一些很粗浅的方法，例如学会控制音量，在重要的部分的时候提亮嗓门，可是收效甚微。</p>
<p>后来我尝试着将课程真正有用的内容减少，多一些无关紧要的信息，甚至是游戏、（冷）笑话。结果就真的很有用，没有人再会在我的演讲中感到睡意昏沉。因为我给他们喘气的机会，是能够体谅他们的疲劳，代价就是我少一些show off而已，就能换来大家的注意力。</p>
<p>这或许也是“罗辑思维”微信号很成功的一个原因。它不仅很短，60秒的语音相信不会让任何人感到疲惫。而且，我还可以随意挑时间去听。“罗辑思维”是新经济——粉丝经济和碎片经济的产物，其中碎片经济，无非就是让人舒服，仅此而已。</p>
<p>做一个让人舒服的人，自己也能舒服。这需要时间去训练，而《蔡康永的说话之道》就是一本不错的伴读物。</p>
<p>祝大家生活开心、愉快。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>练习关心别人，而且表现出你的关心，我觉得是非常值得的，因为你生命中必须有你最在乎的人，你才会活得有滋味。 —— 蔡康永的说话之道</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Reading" scheme="http://blog.leapoahead.com/categories/reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[迭代、递归与Tail Call Optimization]]></title>
    <link href="http://blog.leapoahead.com/2016/01/03/iterative-recursive-process/"/>
    <id>http://blog.leapoahead.com/2016/01/03/iterative-recursive-process/</id>
    <published>2016-01-03T09:59:13.000Z</published>
    <updated>2016-01-03T11:46:27.000Z</updated>
    <content type="html"><![CDATA[<p>在程序设计的世界里面有两种很基本的设计模式，那就是迭代（iterative）和递归（recursive）。这两种模式之间存在着很强的一致性和对称性。</p>
<a id="more"></a>
<p>现在让我来设计一段程序，计算<code>n!</code>，<strong>不能使用任何循环结构</strong>。我们把这个过程封装成一个函数<code>calc</code>，假设<code>n=4</code>，整个计算的<strong>过程（Process）</strong>是这样的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">calc</span><span class="params">(<span class="number">4</span>)</span></span>=<span class="number">4</span>*<span class="function"><span class="title">calc</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc</span><span class="params">(<span class="number">3</span>)</span></span>=<span class="number">3</span>*<span class="function"><span class="title">calc</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc</span><span class="params">(<span class="number">2</span>)</span></span>=<span class="number">2</span>*<span class="function"><span class="title">calc</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc</span><span class="params">(<span class="number">1</span>)</span></span>=<span class="number">1</span>*<span class="function"><span class="title">calc</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc</span><span class="params">(<span class="number">0</span>)</span></span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>对应的<strong>程序（Procedure）</strong>可以被写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    Calculate n!</span><br><span class="line"></span><br><span class="line">    :param n: N</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> n * calc(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>我在上面特别强调了过程和程序的差别，这对后文很重要。Procedure一般也被翻译成过程，为了避免冲突，我将它翻译成程序。过程实际上是一个数学的模型，用文字表述，是比较抽象的；而程序相对而言就是具象化的。程序可以用来实现过程。</p>
<p>将上面的过程展开后可以变成下面这样，我们将之称作<strong>过程A</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">calc(<span class="number">4</span>)=<span class="number">4</span>*calc(<span class="number">3</span>)</span><br><span class="line">=<span class="number">4</span>*(<span class="number">3</span>*calc(<span class="number">2</span>))</span><br><span class="line">=<span class="number">4</span>*(<span class="number">3</span>*(<span class="number">2</span>*calc(<span class="number">1</span>)))</span><br><span class="line">=<span class="number">4</span>*(<span class="number">3</span>*(<span class="number">2</span>*(<span class="number">1</span>*calc(<span class="number">0</span>))))</span><br><span class="line">=<span class="number">4</span>*(<span class="number">3</span>*(<span class="number">2</span>*(<span class="number">1</span>*<span class="number">1</span>)))</span><br><span class="line">=<span class="number">4</span>*(<span class="number">3</span>*(<span class="number">2</span>*<span class="number">1</span>))</span><br><span class="line">=<span class="number">4</span>*(<span class="number">3</span>*<span class="number">2</span>)</span><br><span class="line">=<span class="number">4</span>*<span class="number">6</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>计算<code>n!</code>的过程不止一种。我们还可以想到另外一种计算过程来计算<code>4!</code>。设<code>result</code>为最后的结果。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">result</span>=<span class="number">1</span></span><br><span class="line">n=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">result</span>=<span class="literal">result</span>*n=<span class="number">4</span></span><br><span class="line">n=n-<span class="number">1</span>=<span class="number">3</span></span><br><span class="line"><span class="literal">result</span>=<span class="literal">result</span>*n=<span class="number">12</span></span><br><span class="line">n=n-<span class="number">1</span>=<span class="number">2</span></span><br><span class="line"><span class="literal">result</span>=<span class="literal">result</span>*n=<span class="number">24</span></span><br><span class="line">n=n-<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="literal">result</span>=<span class="literal">result</span>*n=<span class="number">24</span></span><br><span class="line">n=n-<span class="number">1</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>相应的程序实现可以为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    Calculate n!</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> calc_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_iter</span><span class="params">(n, result)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> calc_iter(n - <span class="number">1</span>, result * n)</span><br></pre></td></tr></table></figure>
<p>整个过程展开就变成了</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">calc</span><span class="params">(<span class="number">4</span>)</span></span>=<span class="function"><span class="title">calc_iter</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc_iter</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc_iter</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc_iter</span><span class="params">(<span class="number">2</span>, <span class="number">12</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc_iter</span><span class="params">(<span class="number">1</span>, <span class="number">24</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">calc_iter</span><span class="params">(<span class="number">0</span>, <span class="number">24</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这个展开后的过程我们称之为<strong>过程B</strong>。</p>
<h3 id="递归与迭代">递归与迭代</h3><p>对比过程A和B，过程A看起来比较“浪费空间”，至少我得打更多的字表达它。它们之间最大的区别是，在过程A中，前一次计算的结果要靠后一次计算的结果以及它本身的参数结合才能得出来。例如在计算<code>calc(4)=4*calc(3)</code>的时候，<code>calc(3)</code>就是下一次计算的结果，而<code>4</code>是<code>calc(4)</code>本身的参数。</p>
<p>反之，在过程B中，前一次计算的结果和后一次计算的结果都通过参数传递。每次计算的参数就是这次计算所需的所有<strong>状态</strong>。如果你读过我写的<a href="http://blog.leapoahead.com/2015/09/19/function-as-first-class-citizen/">“函数是一等公民”背后的含义</a>，你就会发现这是函数式编程里面纯函数的特性。</p>
<p>过程A，这类前一次计算依赖于自身状态和后一次计算的结果的过程我们就称之为递归过程（Recursive Process），因为它最后总要回到之前的计算中才能获得最后结果；而过程B，这类每次计算结果仅依赖于自身状态的过程我们就称之为迭代过程（Iterative Process）。</p>
<h3 id="Tail_Call_Optimization_(TCO)">Tail Call Optimization (TCO)</h3><p>如果我们观察上面的第二段程序，我们会说这是一个递归函数，因为它用了函数的递归调用。但是我们已经提到了，它实际上是一个迭代过程，而不是递归过程。因为每一次调用<code>calc_iter</code>的时候，本次计算的结果都能由自身状态得出来。它完全可以被重写为</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def calc(n):</span><br><span class="line">    <span class="string">"""</span><br><span class="line">    Calculate n!</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="type">ValueError</span></span><br><span class="line">    <span class="literal">result</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="literal">result</span>, n = <span class="literal">result</span> * n, n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span></span><br></pre></td></tr></table></figure>
<p>因此，尽管有些函数被写成了递归的形式，它依然可能是表示一个迭代的过程。很有趣的是，尽管它是迭代过程，但是它还是占用了栈空间。如果<code>n</code>足够大的话，这个迭代过程依然可能跟传统的递归函数实现一样产生栈溢出。</p>
<img src="/2016/01/03/iterative-recursive-process/1.jpg" alt="Stack Overflow" title="Stack Overflow">
<p>既然每次计算都包含着本次计算所需的所有状态，那就说明我们实际上没有必要把前面一次计算的函数调用推入栈中。因为无论如何，我们都不会再用到之前的调用了。这种不将前一次函数调用推入栈中的优化就被称作Tail Call Optimization。之所以叫Tail Call是因为在用递归函数实现迭代过程的时候，对下一次计算过程的调用都在尾部。理由很简单，因为我们不再需要回到这个函数，所以在递归调用之后就不需要有其他的逻辑了。</p>
<h3 id="TCO的实现">TCO的实现</h3><p>目前TCO的实现还局限在一些纯函数式编程语言例如Common Lisp。大部分常用的语言并没有实现TCO，但是认识到TCO可以帮助我们更好地理解我们所设计的迭代或者递归过程。</p>
<p>Python、Java之类的非纯函数式编程语言没有实现TCO的表面原因是因为Stack trace。如果实现了TCO，那么在执行被TCO的函数期间遇到错误的时候就无法打印出Stack trace，因为这样的函数执行时不存在推入Stack的说法。</p>
<img src="/2016/01/03/iterative-recursive-process/2.jpg" alt="Stack trace - Java" title="Stack trace - Java">
<p><a href="https://www.quora.com/Why-is-tail-recursion-optimisation-not-implemented-in-languages-like-Python-Ruby-and-Clojure-Is-it-just-difficult-or-impossible" target="_blank" rel="external">图片来源</a></p>
<h3 id="阅读书目">阅读书目</h3><ul>
<li>Structure and Interpretation of Computer Program, Chapter 1</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在程序设计的世界里面有两种很基本的设计模式，那就是迭代（iterative）和递归（recursive）。这两种模式之间存在着很强的一致性和对称性。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[硅谷夜谈]]></title>
    <link href="http://blog.leapoahead.com/2015/12/27/thinking-in-silicon-valley/"/>
    <id>http://blog.leapoahead.com/2015/12/27/thinking-in-silicon-valley/</id>
    <published>2015-12-27T14:45:32.000Z</published>
    <updated>2015-12-28T09:27:45.000Z</updated>
    <content type="html"><![CDATA[<p>旧金山严格意义上不算是硅谷的一部分，它其实坐落于硅谷以北。城市的占地面积不大，百分之九十是一马平川的居民区。东北角的Financial District是这里唯一高楼耸立的区域，人如川流，在他们之中不少都是科技工作者。贯穿整个Financial District的是Market Street，好似是旧金山的脊柱一般，撑着这个科技之都鲜活的躯体。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/1.jpg" alt="Market Street" title="Market Street">
<p>随着越来越多的硅谷公司北上，旧金山其实和硅谷已然是浑然不可分的一体了。我从今年的年中来到旧金山，我是吴迪，我来这里探寻我的新生活，开启我的黄金十年。</p>
<p>丰富的想象力曾经让我以为旧金山是一个被繁华笼罩的城市，路边会有机器人行走，街上无人车穿梭，灯火明灭中传到耳轮里的都是忙碌的键盘声，满一副未来之城的景象。</p>
<p>然而，这却是个安静平和的小城，没有任何大城市的架子。反之，旧金山的主题是绿色。从街上到处横冲直撞、违反交通规则的鸽子，还有在任何地方都可能和你同屏出现的宠物狗们，处处体现着这个城市对自然的尊敬。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/2.jpg" alt="旧金山的鸽子" title="旧金山的鸽子">
<p>我在一家名为Yelp的公司工作，这是运行了十多年却依然保持创业文化的公司，这里有近三千人。公司的办公楼曾是一座邮政大楼，坐落在140 New Montgomery Street。New Montgomery Street的百年历史中，Yelp陪伴了它已经整整十一年。略有纽约帝国大厦之风的楼宇，门口赫然置有带着公司Logo的门牌。当我第一次到那里时，我感觉到会有很有趣的故事即将开始。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/4.jpg" alt="Yelp" title="Yelp">
<p>今年的三月，我拿到了Yelp的Offer，于是来到了这家美国最大的商业点评网站的流量团队。这是一只除了我之外仅有五个人的团队，我们的共同目标是通过搜索引擎优化来提高Yelp的桌面端客户流量。整个Yelp的工程部门，含上英国伦敦和德国汉堡的团队，约有四百人上下。这在如今的科技公司中其实算是个很小的团队，和动辄上万工程师的巨兽们自然没法比。</p>
<p>我有另外一篇文章（英文），专门描述了Yelp的工程文化，<a href="https://www.linkedin.com/pulse/inside-yelps-engineering-culture-john-wu?trk=prof-post" target="_blank" rel="external">题为《Inside Yelp’s Engineering Culture》</a>。一言以蔽之，在Yelp，人们总是关注着打磨（Polish）好产品。</p>
<p>Yelp是一个速度相对较慢，在湾区的科技行业中具有独立的风格的公司。它在人们在外界所能看到的部分或许不如Google、Facebook等公司华丽，甚至一度被不断下挫的股价所饱受议论，但是从工程团队的角度讲，它是独特且出众的。对于我而言，是第一份工作的最好的选择。</p>
<p>我经历了很多心态的变化。我不是很在意我能在工作中拿多少工资；我不在意我能在多有名的公司工作；我也不在意我日后必然来到的创业年华是否能让我功成名就……我在意的是，我是否能够将工作和生活调和得恰到好处；我是否每天都能学习到新东西；我是否能在自己一个人的世界中寻找到生活快乐。</p>
<p>旧金山给我展现的，就是生活，而工作只是很小的一部分。走在街上，人们无论互相之间是否认识，都会互相微笑着打招呼，礼貌地问着“How is it going?”；到了周末，很少有人工作，他们希望将周末的时间留给自己的家人；父母们是孩子最好的导师，他们带孩子到博物馆一起学习最新的科学知识、和孩子一起到咖啡店看书、尽量认识孩子的每一个朋友，并和他们也成为朋友……</p>
<p>我走过了纽约、华盛顿、波士顿、芝加哥、圣地亚哥、芝加哥、拉斯维加斯等美国的城市，没有一个城市如旧金山一样，是这样如此开心的城市。我经常和人感叹，”San Francisco is an incredibly happy city”。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/5.jpg" alt="Happy City" title="Happy City">
<p>在旧金山生活的核心概念是<strong>社区</strong>。这一点从环境上面就能看出来。在很多AirBnB上出租的旧金山房屋中，都会贴有这样一则告示，“California is in a severe drought, please save every drop of water.”（加州正在经历着严重的干旱，请节约每一滴水）。当和人们谈起他们的社区，他们总是很有话说，有着自己的见解。</p>
<p>不知道什么时候可以在寻常中国家庭、街道里面看到百姓自发地宣传，“我们的国家正在遭遇严重的空气污染危机，请尽量以步代车”，或者，“请及时对您的爱车进行尾气排放检查，对不合格的车进行尾气过滤处理”。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/6.jpg" alt="Community" title="Community">
<p>社区的概念贯穿始终，在技术圈子依然如此。人们热衷于分享，分享对它们而言不是每日要执行的“任务”，而是源于自发的对技术的热爱。也因此，他们所分享的内容其实跟自己的工作公司大多没什么关系，而是一些自己的独到见解。这一点我很是喜欢。国内常见的“架构”、“业务”、“上亿”等等高屋建瓴的话题在这里很少见，人们关心的是技术具体如何运作，而不是如何帮助自己更好地赚钱。</p>
<p>分享，发自的是内心的热爱，为的是社区的发展，投资的是公司的未来。开源亦是如此，这才是开放的信条。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/7.jpg" alt="分享" title="分享">
<p>中国的科技公司喜欢自我感动，觉得他们快要赶超硅谷了，站上世界舞台了。可硅谷超越我们的远不止是科技，而是几乎每个不同的角度。这句话说起来一定让很多人嗤之以鼻，但却是我切身的感受。</p>
<p>我希望我的国家，最终，也能够成为一个快乐的国家。少一点浮夸，多一些脚踏实地的快乐。</p>
<p>不久之后我就会暂时离开这里，可这永远不是结束。我说过，这是属于我的黄金十年的开始。或许我半年之后还会选择回来，也或许我会选择直接在国内工作和生活。只要常怀感恩之心，感恩生活，这十年就不会怕火炼。</p>
<p>感谢Bill给我这次赴美的机会；感谢在这几个月中曾经远道而来的老妈，我很高兴她在这里的十几天里面过得很快乐；特别感谢Cavaliers一家对我的照顾；感谢在湾区的新老朋友（特别是桢哥）；感谢我自己给自己做的每一个决定。</p>
<img src="/2015/12/27/thinking-in-silicon-valley/8.jpg" alt="湾区俯瞰" title="湾区俯瞰">
<p>草草收尾，朕累了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>旧金山严格意义上不算是硅谷的一部分，它其实坐落于硅谷以北。城市的占地面积不大，百分之九十是一马平川的居民区。东北角的Financial District是这里唯一高楼耸立的区域，人如川流，在他们之中不少都是科技工作者。贯穿整个Financial District的是Mark]]>
    </summary>
    
      <category term="Life" scheme="http://blog.leapoahead.com/categories/life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Debugging with strace]]></title>
    <link href="http://blog.leapoahead.com/2015/11/27/debugging-with-strace/"/>
    <id>http://blog.leapoahead.com/2015/11/27/debugging-with-strace/</id>
    <published>2015-11-26T16:32:56.000Z</published>
    <updated>2015-11-27T09:20:47.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://linux.die.net/man/1/strace" target="_blank" rel="external">strace</a> is a tool that helps to inspect system calls your application makes. I found it really useful this week when I debugging a complex python application. I am not going through my original problem though, but will show you some typical examples as proof of concept.</p>
<a id="more"></a>
<p>Let’s start with a basic scenario, file I/O on local filesystem. Suppose we have a powerful python script <strong>traceme.py</strong>, whilst there isn’t a <strong>a.txt</strong>.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># traceme.py</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">'a</span>.txt') <span class="keyword">as</span> f:</span><br><span class="line">    f.readline<span class="literal">()</span></span><br></pre></td></tr></table></figure>
<p>If we run it, not surprisingly you are getting <code>IOError</code>.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="operator"><span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line"><span class="keyword">File</span> <span class="string">"strace_me.py"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">  <span class="keyword">with</span> <span class="keyword">open</span>(<span class="string">'a.txt'</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">  IOError: [Errno <span class="number">2</span>] <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> <span class="keyword">directory</span>: <span class="string">'a.txt'</span></span></span><br></pre></td></tr></table></figure>
<p>But let’s say for some reason, sometimes we don’t get the name of the missing file. That was what happened to me earlier this week, and I got so confusing just because I didn’t know what was missing out there.</p>
<p>I then ended up using <strong>strace</strong>, trying to find out what system call my program made. The simplies use case of <strong>strace</strong> is barely prepending command <code>strace</code> to the command you want to debug.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace <span class="keyword">python</span> traceme.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
<p>A bunch of blazing long message will be shown like following.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0x7f6f772e9000</span></span><br><span class="line">lseek(<span class="number">3</span>, <span class="number">0</span>, SEEK_CUR)                   = <span class="number">0</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">"with open('a.txt') as f:\n    f.r"</span>..., <span class="number">4096</span>) = <span class="number">42</span></span><br><span class="line">lseek(<span class="number">3</span>, <span class="number">42</span>, SEEK_SET)                  = <span class="number">42</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">""</span>, <span class="number">4096</span>)                       = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x7f6f772e9000</span>, <span class="number">4096</span>)            = <span class="number">0</span></span><br><span class="line">open(<span class="string">"a.txt"</span>, O_RDONLY)                 = -<span class="number">1</span> ENOENT (No such file or directory)</span><br><span class="line">write(<span class="number">2</span>, <span class="string">"Traceback (most recent call last"</span>..., <span class="number">35</span>Traceback (most recent call last):</span><br><span class="line">) = <span class="number">35</span></span><br><span class="line">write(<span class="number">2</span>, <span class="string">"  File \"traceme.py\", line 1, in "</span>..., <span class="number">41</span>  File <span class="string">"traceme.py"</span>, line <span class="number">1</span>, in &lt;module&gt;</span><br><span class="line">) = <span class="number">41</span></span><br><span class="line">open(<span class="string">"traceme.py"</span>, O_RDONLY)            = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">42</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0x7f6f772e9000</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">"with open('a.txt') as f:\n    f.r"</span>..., <span class="number">4096</span>) = <span class="number">42</span></span><br><span class="line">write(<span class="number">2</span>, <span class="string">"    "</span>, <span class="number">4</span>    )                     = <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Those are all system calls your program made at runtime. Apparently, according the the following line, we can address the name of the missing file.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">"a.txt"</span>, O_RDONLY)                 = -<span class="number">1</span> ENOENT (No such <span class="built_in">file</span> <span class="operator">or</span> <span class="built_in">directory</span>)</span><br></pre></td></tr></table></figure>
<p>It also told you that this file was supposed to be opened in readonly mode. You will find many system calls interesting if you are not very familiar with kernel level programming.</p>
<p>You can make your life way more easier buy just tracing a specific kind of system calls. In our case, my point of interest should be <code>open</code>. Use <code>-e trace=&lt;comma-separated-list-of-system-call-categories&gt;</code> to designate that.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace -<span class="keyword">e</span> trace=<span class="keyword">open</span> <span class="keyword">python</span> traceme.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
<p>Then hopefully we are getting a much simpler and cleaner output.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">"/usr/lib/python2.7/encodings/ascii.py"</span>, O_RDONLY)</span></span> = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">"/usr/lib/python2.7/encodings/ascii.pyc"</span>, O_RDONLY)</span></span> = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">"traceme.py"</span>, O_RDONLY)</span></span>            = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">"traceme.py"</span>, O_RDONLY)</span></span>            = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(<span class="string">"a.txt"</span>, O_RDONLY)</span></span>                 = -<span class="number">1</span> ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>
<p>You can also attach a <strong>strace</strong> session to a running process by setting <code>-p</code> parameter to the pid of process you are interested in. That will be super helpful when debugging your running web application.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@dev:~<span class="preprocessor"># strace -p <span class="number">15427</span></span></span><br><span class="line">Process <span class="number">15427</span> attached - <span class="function">interrupt to quit</span><br><span class="line"><span class="title">futex</span><span class="params">(<span class="number">0x402f4900</span>, FUTEX_WAIT, <span class="number">2</span>, <span class="literal">NULL</span>)</span> </span><br><span class="line">Process 15427 detached</span></span><br></pre></td></tr></table></figure>
<p>You can even do profiling to all the system calls your code made by using <code>-c</code> parameter. I personally think <code>c</code> stands for collecting. It’s a really powerful tool for you to understand performance issues from a low-level ground.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"><span class="number">100.00</span>    <span class="number">0.000006</span>           <span class="number">0</span>        <span class="number">65</span>           close</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>        <span class="number">98</span>           read</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>         <span class="number">8</span>           write</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>       <span class="number">222</span>       <span class="number">159</span> open</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>        <span class="number">83</span>        <span class="number">57</span> stat</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>        <span class="number">95</span>           fstat</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>         <span class="number">5</span>           lstat</span><br><span class="line">  <span class="number">0.00</span>    <span class="number">0.000000</span>           <span class="number">0</span>         <span class="number">3</span>           lseek</span><br></pre></td></tr></table></figure>
<p>You can tell from the result that <code>open</code> system call is obviously is the performance bottleneck of the powerful app we just wrote.</p>
<p>I use <strong>strace</strong> whenever I don’t have enough context of what my app is doing with the operating system. You can even use it to debug internet connection by tracing <code>poll,select,connect,recvfrom,sendto</code> system calls, which is super handy :P.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://linux.die.net/man/1/strace">strace</a> is a tool that helps to inspect system calls your application makes. I found it really useful this week when I debugging a complex python application. I am not going through my original problem though, but will show you some typical examples as proof of concept.</p>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://blog.leapoahead.com/categories/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于实现Chrome DevTools选择性Cache的提议]]></title>
    <link href="http://blog.leapoahead.com/2015/10/26/chrome-devtools-selective-caching-proposal/"/>
    <id>http://blog.leapoahead.com/2015/10/26/chrome-devtools-selective-caching-proposal/</id>
    <published>2015-10-26T14:56:16.000Z</published>
    <updated>2015-10-27T06:02:28.000Z</updated>
    <content type="html"><![CDATA[<p>我们都爱Chrome DevTools！作为Web工程师，我们每天都使用DevTools。</p>
<a id="more"></a>
<p>在使用DevTools的过程中，我们会使用“Disable Cache (while DevTools is opened)”这个功能。在开发环境中，这个功能让我们在打开DevTools的时候，每次刷新都能获取到最新版本的静态资源。</p>
<p>但是这个功能的弊端就是，当我们的页面在有过多静态资源的时候，就需要等非常之久。为了解决这个问题，我提出了选择性Cache的提议，可以在<a href="https://docs.google.com/document/d/19dkHl9fRbO_bN-jH_OSkbsNtq4MT4c2ZL8cqX7llY0U/edit#heading=h.3x8nyq2w3lbm" target="_blank" rel="external">这个Google Docs</a>上面看到。</p>
<p>希望大家可以加入这里的讨论，让我们一起让DevTools变得更好！：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们都爱Chrome DevTools！作为Web工程师，我们每天都使用DevTools。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Galley - 为基于Docker架构本地开发与测试提速]]></title>
    <link href="http://blog.leapoahead.com/2015/10/23/intro-to-galley/"/>
    <id>http://blog.leapoahead.com/2015/10/23/intro-to-galley/</id>
    <published>2015-10-22T16:40:01.000Z</published>
    <updated>2015-10-23T07:44:59.000Z</updated>
    <content type="html"><![CDATA[<p>（本文投稿于<a href="www.infoq.com/cn/">InfoQ</a>，无论其是否刊登，其他第三方转载请务必注明出处）</p>
<p>现如今，Docker已经成为了很多公司部署应用、服务的首选方案。依靠容器技术，我们能在不同的体系结构之上轻松部署几乎任何种类的应用。在洛杉矶时间2015年10月21日于旧金山展开的Twitter Flight开发者大会上，来自Fabric的工程师Joan Smith再次谈到了这一点。</p>
<a id="more"></a>
<p>她提到，尽管我们在部署应用的时候将容器技术应用得淋漓尽致，但是在开发和测试的时候还是面临着很多问题。在从前，她所在的团队的本地开发方案是用Vagrant和Chef来支撑的。Vagrant是基于虚拟机的一套本地开发方案，而Chef是一套IT架构自动化部署方案。</p>
<p>Joan认为，使用类似Vagrant、Chef的方案来部署本地开发方案会很浪费开发时间（Engineering Time）。她的理由主要有三点。</p>
<p>第一：微服务盛行。这一趋势的直接影响之一就是，每个服务自身的配置会不断变动，互相之间的依赖关系也会不断变动。今天的一个服务，明天就可能被拆分成三个服务。那么，如果你要在本地启动开发环境，那么你就需要知道所有服务之间架构的信息才能够让应用在本地跑起来。</p>
<p>然而大部分时候，我们在开发一个服务的时候是不需要知道整个架构的。例如，当我们在测试下图中www和www-db之间的一些功能的时候，我们其实根本可以不用关心crash service是怎么样的。</p>
<img src="/2015/10/23/intro-to-galley/1.png" alt="整个应用的架构可以是很复杂的" title="整个应用的架构可以是很复杂的">
<p>所以，更多时候在微服务的世界里，我们只关心我们应该关心的部分。对于不关心的部分，例如crash service，我们有一种方案就是可以用Mock来代替它。</p>
<img src="/2015/10/23/intro-to-galley/2.png" alt="我们真正关心的部分只是其中一部分" title="我们真正关心的部分只是其中一部分">
<p>第二：Chef之类的架构自动化部署方案是叠加式（additive）的。往你的现有架构上面加东西很容易，但是想要拿掉一些东西的时候就很困难。</p>
<p>第三：在持续集成的环境中，Vagrant不具备可扩展性（Vagrant on CI just doesn’t scale）。由于Vagrant是基于虚拟机的，在运行过一次CI上的Pipeline任务之后，虚拟机就会被污染（polluted），无法用于下一次的任务执行。</p>
<p>基于对现有本地开发普遍方案的这些问题，Joan提出了她的看法：我们为什么不利用好Docker这个平台，让它在本地开发、测试的时候也能跟线上保持一致呢？但是如果直接用Docker命令行来启动应用，手动管理依赖，那么时间成本也很大。Docker Compose确实能够胜任一次性启动多个容器的任务，但是它依然不够灵活。</p>
<p>随后，Joan介绍了Galley，一个为本地开发、测试而设计的组合并协调（orchestrating）Docker容器的命令行工具。</p>
<p>她还风趣地提到，Vagrant的意思漂泊的，Chef的意思是厨师，而Galley的意思就是漂泊的厨师（原意是船上的厨房）。</p>
<p>Galley最大的优点就是能让工程师在本地基于自己的代码构建镜像并运行，这些本地构建的代码是他们当前在完成的特性所关心的部分；而对于他们不关心的部分，例如上面提到的crash service，Galley则自动改用Docker Hub（或者私有的Hub）中已经构建好了的镜像来直接运行。</p>
<p>Galley采用一个集中的Galleyfile描述整个应用的架构。Galleyfile是一个JavaScript文件，它的module.exports对象即为你所有服务容器的描述。例如下面就是一个合法的Galleyfile的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  CONFIG: &#123;</span><br><span class="line">    registry: <span class="string">'docker-registry.your-biz.com'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">'config-files'</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">'beanstalk'</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">'www-mysql'</span>: &#123;</span><br><span class="line">    image: <span class="string">'mysql'</span>,</span><br><span class="line">    stateful: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">'www'</span>: &#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">      RAILS_ENV: &#123;</span><br><span class="line">       <span class="string">'dev'</span>: <span class="string">'development'</span>,</span><br><span class="line">       <span class="string">'test'</span>: <span class="string">'test'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    links: &#123;</span><br><span class="line">      <span class="string">'dev'</span>: [<span class="string">'www-mysql:mysql'</span>, <span class="string">'beanstalk'</span>],</span><br><span class="line">      <span class="string">'test'</span>: [<span class="string">'www-mysql'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    ports: &#123;</span><br><span class="line">      <span class="string">'dev'</span>: [<span class="string">'3000:3000'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    source: <span class="string">'/code/www'</span>,</span><br><span class="line">    volumesFrom: [<span class="string">'config-files'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面，我们定义了所有容器来源的Registry。一般情况下，这会是你自己公司内部的私有Registry。另外，我们还定义了四个容器config-files、beanstalk、www-mysql和www。这四个容器都是在上面指定的Registry可以下载到的。</p>
<p>假设www容器是我们正在开发的服务，那么我们一般会用”galley run www.dev –rsync -s .” 命令启动www容器，并且是在dev环境。在Galley里有两个环境，一个是dev，一个是test。这时候Galley会为我们做几件事情：</p>
<p>将source属性指定的文件夹（在容器内）和当前galley run指定的目录同步。Galley的支持使用rsync将源码拷贝到Docker所在的机器中。这对于在Mac下开发的人们来说是个很好的特性，因为Docker的volume支持默认采用VirtualBox的Shared Folder功能，而这一功能的效率很低。<br>links属性中的dev属性指明了在dev环境下www应用的依赖项。Galley会为我们将这些依赖的容器全部pull到本地并且启动，并自动和www链接在一起。在这里，Galley就会pull并link两个容器，一个是www-mysql:mysql，一个是beanstalk。对于在volumesFrom（对应Docker的volumes-from）指定的容器，Galley也会自动pull并部署。<br>应用环境变量。在这里，www是一个小型Rails应用，于是我们可以应用一些Rails应用的环境变量。<br>进行端口映射</p>
<p>更完整的配置方法可以参考<a href="https://github.com/twitter-fabric/galley#rsync-support" target="_blank" rel="external">Galley的官方文档</a>。</p>
<p>我们可以注意到，在第二点中，Galley只会帮我们获取我们当前开发所关心的服务，其他不相关的服务，Galley不会获取并部署它们。</p>
<p>默认情况下，galley run每次都会重新创建我们当前正在开发的应用的容器。对于依赖项，在满足一定条件的时候也会重新创建（见文档）。我们注意到www-mysql容器是stateful（有状态的）的，因为它是一个数据库容器。对于stateful的容器，Galley不会自动重新创建它们，保证开发用的数据不会因为重新创建容器而丢失。</p>
<p>Galley另外一点很有趣的地方是可以创建附加项（Addons）。所谓附加项就是允许开发者通过命令行来手动指定一些容器的行为。这样说很抽象，我们来看一个例子。下面是一段Addons的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  …</span><br><span class="line">  ADDONS: &#123;</span><br><span class="line">    <span class="string">'beta'</span>: &#123;</span><br><span class="line">      <span class="string">'www'</span>: &#123;</span><br><span class="line">        env: &#123;</span><br><span class="line">          <span class="string">'USE_BETA_SERVICE'</span>: <span class="string">'1'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        links: [<span class="string">'beta'</span>, <span class="string">'uploader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'uploader'</span>: &#123;</span><br><span class="line">        env: &#123;</span><br><span class="line">          <span class="string">'USE_BETA_SERVICE'</span>: <span class="string">'1'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在用galley run运行的时候，加入-a beta参数，那么在ADDONS.beta对象里面的所有配置也会被应用。例如，在这里www服务就被应用了额外的环境变量USE_BETA_SERVICE，而且还应用了额外的link containers。</p>
<p>聪明的读者可以猜猜，USE_BETA_SERVICE这个环境变量的作用是什么？启动Mock模式！在前面我们提到，很多时候我们可以使用Mock的方式来模拟一个正常运作的服务（一般是依赖项），从而我们最多只需要关注直接依赖项，而不需要关注依赖项的依赖项。当然了，从笔者本人的角度来看，Mock这种方法并不是银弹。即便如此，在一些情景下它也能缩小我们所要关心的范围。</p>
<p>基于Vagrant开发的又一问题是，Docker的Vagrant配置是Hostonly网络，也就是说你没有办法直接从除了你自己本地机器外其他的地方很容易地连接到你的Docker容器。对此，Galley的进程还启动了TCP Proxy，将发往本地机器端口的流量代理到Docker的Vagrant虚拟机，这样即便你是在调试手机应用，也可以轻松、直接地访问到自己的机器了。</p>
<p>最后Joan还展示了Fabric团队自身使用Galley进行开发的示例，可以看到Galley确实在一定程序上极大地简化了Fabric团队本地开发和测试的工作流。</p>
<p>建议感兴趣的读者可以自己使用Galley体验一下，感受它所带来的方便和潜在的痛点。如果它确实在你自己的应用体系中能够很完美地胜任协调本地开发、测试的容器依赖协调工作的话，那么何乐而不为呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>（本文投稿于<a href="www.infoq.com/cn/">InfoQ</a>，无论其是否刊登，其他第三方转载请务必注明出处）</p>
<p>现如今，Docker已经成为了很多公司部署应用、服务的首选方案。依靠容器技术，我们能在不同的体系结构之上轻松部署几乎任何种类的应用。在洛杉矶时间2015年10月21日于旧金山展开的Twitter Flight开发者大会上，来自Fabric的工程师Joan Smith再次谈到了这一点。</p>]]>
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.leapoahead.com/categories/DevOps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我从开源项目中学习到的Docker经验]]></title>
    <link href="http://blog.leapoahead.com/2015/10/07/docker-lessons-learned-md/"/>
    <id>http://blog.leapoahead.com/2015/10/07/docker-lessons-learned-md/</id>
    <published>2015-10-07T11:42:44.000Z</published>
    <updated>2015-10-08T04:30:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近几周从一个Web开发俨然摇身一变成了“运维”，在GitHub上面为<a href="https://github.com/EverythingMe/redash" target="_blank" rel="external">re:dash</a>做Docker化的支持。在整个Code Review的过程中汲取了一些Docker的经验。</p>
<a id="more"></a>
<h3 id="不要build">不要build</h3><p>不要在构建Docker镜像的时候build。这里的build指的是将代码编译至production-ready的过程。例如，在一个Web应用中，用<code>make</code>将静态资源最小化（minify）、拼接（concatenate），以及配置文件的生成等。</p>
<img src="/2015/10/07/docker-lessons-learned-md/build-process.png" alt="Build Process" title="Build Process">
<p>仔细思考Docker要解决的主要问题，就是如何跨越操作系统的限制进行部署。因此构建Docker镜像的过程中，我们也只应该专注镜像本身环境的搭建，例如系统软件、python依赖项等。python的依赖项是比较特殊的，因为它们一般是安装在系统层面上的。</p>
<p>如果是Node.js的非全局依赖项，那么也无需在镜像中来下载安装，而是在build的过程中下载，然后直接在<strong>Dockerfile</strong>中<code>Copy</code>到镜像中。</p>
<h3 id="合理地将相同的指令结合">合理地将相同的指令结合</h3><p>Docker在构建镜像的过程中，每运行<strong>Dockerfile</strong>的一个指令，都会构建出一个<em>layer</em>。一个镜像就是由许多的<em>layer</em>叠加而成的，这样的设计允许Docker能够缓存我们镜像中特定的一些部分，之后如果对<strong>Dockerfile</strong>进行修改的话，一般情况下能通过缓存加快构建的效率。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get -y install libpq-dev postgresql-client</span></span><br></pre></td></tr></table></figure>
<p>上面两条<code>RUN</code>指令分别会创建两个layer。当指令数量过多的时候，layer就会多到爆了，甚至会提示你磁盘空间已经不够用了。</p>
<p>更好的方式是将两条相同的指令合理地合成一条。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-<span class="built_in">get</span> <span class="keyword">update</span> &amp;&amp; \</span><br><span class="line">    apt-<span class="built_in">get</span> -y install libpq-<span class="built_in">dev</span> postgresql-client</span><br></pre></td></tr></table></figure>
<p>这样构建过程中就只会产生一个layer，减少磁盘空间的消耗。</p>
<h3 id="镜像应该各司其职">镜像应该各司其职</h3><p>每个镜像应该各司其职，这背后的主要目的是为了可扩展性考虑。</p>
<p>如果你有一个这样的镜像……</p>
<img src="/2015/10/07/docker-lessons-learned-md/all-in-one-container.png" alt="all-in-one container" title="all-in-one container">
<p>那么你可能觉得很方便！的确，你只要简单地<code>docker run</code>一下就可以结束工作，到一旁喝咖啡了。</p>
<p>但是当你的应用需要扩展（scale）的时候，你可能就要抓耳挠腮了。将所有的东西通通放在一个容器里面，你就没有办法做横向的扩展。</p>
<p>横向扩展，也称作<strong>X-axis scaling</strong>，主要通过复制现有的服务来提高该服务的可用性、并通过负载均衡将请求分散给该服务的诸多“复制品”，提供服务的速率等。横向扩展是3D扩展模型（# Dimensions to Scaling）中的一种。</p>
<img src="/2015/10/07/docker-lessons-learned-md/3d-scale-model.jpg" alt="3D扩展模型" title="3D扩展模型">
<p>其中，横向扩展（X-axis scaling）通过复制的方式。纵向扩展（Y-axis scaling）通过将应用功能分解，每个服务运行的代码都不同。最后一个Z-axis scaling通过将数据划分成多块，并由多个服务使用。每个服务上运行的代码是一致的，而所负责的数据分区则不同。如果你感兴趣，可以看<a href="http://microservices.io/articles/scalecube.html" target="_blank" rel="external">The Scale Cube</a>这篇文章（上面的图片出于此）。</p>
<p>如果一个镜像中同时打包了一个Web应用、postgres和nginx三个不同的服务，那么我们就无法单独地对Web App本身进行复制，横向扩展；也无法对单独将postgres的数据进行扩展。</p>
<p>相反，如果这三个服务分别被构建到不同的Docker镜像之后，我们就可以轻松地进行扩展了。在这之中，可以应用<a href="https://docs.docker.com/compose/" target="_blank" rel="external">Docker Compose</a>轻松启动一系列的镜像，并将它们互相连接在一起。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近几周从一个Web开发俨然摇身一变成了“运维”，在GitHub上面为<a href="https://github.com/EverythingMe/redash">re:dash</a>做Docker化的支持。在整个Code Review的过程中汲取了一些Docker的经验。</p>]]>
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.leapoahead.com/categories/DevOps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“函数是一等公民”背后的含义]]></title>
    <link href="http://blog.leapoahead.com/2015/09/19/function-as-first-class-citizen/"/>
    <id>http://blog.leapoahead.com/2015/09/19/function-as-first-class-citizen/</id>
    <published>2015-09-18T17:37:41.000Z</published>
    <updated>2015-09-19T08:37:41.000Z</updated>
    <content type="html"><![CDATA[<p>在学习一些语言的时候，你经常会听到“函数是一等公民”这样的描述。那么究竟函数在这类语言中扮演着怎么样的一个角色？它和函数式编程、无状态设计、封装抽象有什么千丝万缕的联系？</p>
<a id="more"></a>
<p>在本文中，我们用JavaScript为例，娓娓道来这其中的故事。当然了，只是我发现的这一部分……</p>
<h3 id="时间的奥秘">时间的奥秘</h3><p>我们从最简单的五行代码说起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>是的，我写JavaScript不加分号。当然，关键不是这个……</p>
<p>我们可以很轻松地写出关于这个函数的测试用例来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'add'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'should return a + b'</span>, () =&gt; &#123;</span><br><span class="line">        add(<span class="number">1</span>, <span class="number">2</span>).should.equal(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是如果我们引入一个全局的变量C。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> C = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addWithC</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + C</span><br><span class="line">&#125;</span><br><span class="line">addWithC(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">addWithC(<span class="number">5</span>, <span class="number">2</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>这个代码看起来还是很好测试的，只要你在测试中也能访问到<code>C</code>这个变量。你修改两三次<code>C</code>的值，然后运行几次被测试的函数，大概地看下结果是不是正确“就行了”。</p>
<p>慢着，看似平静的表象下，就是一切问题的开始。我们编写一个函数，里面只是简单地调用<code>addWithC</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addWithC(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>foo</code>在这里成为了<code>addWithC</code>的一个抽象。你怎么样<strong>较为全面地</strong>测试<code>foo</code>？很显然，你依然还是要在它的测试里面去引用到<code>C</code>。</p>
<p>好的，在这里，<code>C</code>就成为了一种<strong>状态(State)</strong>，它的变化可以左右函数的输出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addWithC(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">C = <span class="number">1</span></span><br><span class="line">addWithC(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>第二句<code>C = 1</code>的玄妙之处在于，它在这三行代码中创建了“时间”这个纬度。你可能在想，这是什么鬼话？</p>
<p>别急，请仔细看。在阅读这份代码的时候，我们会说：</p>
<blockquote>
<p>在<code>C = 1</code>之前，<code>addWithC(1, 2)</code>的结果是3；在<code>C = 1</code>之后，<code>addWithC(1, 2)</code>的结果是4。</p>
</blockquote>
<p>看，这不就是时间吗？我们在这里有了之前和之后的概念。这也称作“副作用” —— <code>C</code>的变化对<code>addWithC</code>的结果产生了<strong>副作用</strong>。</p>
<p>如果我们回到引用<code>C</code>这个状态之前的<code>add</code>函数呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>我们会说：</p>
<blockquote>
<p><code>add(1, 2)</code>的结果就是3；<code>add(4, 5)</code>的结果就是9</p>
</blockquote>
<p><code>add</code>比<code>addWithC</code>来得好测试。为什么呢？因为<strong>对于固定的输入，<code>add</code>总是可以有固定的输出</strong>。但是<code>addWithC</code>并不是这样的，因为在不同的“时间”里（也就是状态取不同的值的时候），它对于同样的输入，不一定有同样的输出。</p>
<p>其实这一点在编写测试的时候，编写行为描述的时候就可以发现了。在进行<a href="https://zh.wikipedia.org/zh/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91" target="_blank" rel="external">行为驱动开发</a>编写行为描述的时候，我们应该描述清楚被测函数的下面几个方面</p>
<ul>
<li>它所期待的输入是什么</li>
<li>输入所对应的输出是什么</li>
</ul>
<p>例如，对于<code>add</code>，我就可以写道</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should return sum of a and b'</span>, ...)</span><br></pre></td></tr></table></figure>
<p>对于<code>addWithC</code>，我们要写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should return sum of a, b and an external C'</span>, ...)</span><br></pre></td></tr></table></figure>
<p>看到了吧，通过编写行为描述，我们发现在单元测试中，竟然还引入了外部变量。这还能叫单元测试吗？</p>
<p>很多时候，我们可能会选择破例在单元测试里面引入状态，而不去思考重新修改代码。因此，系统中引入了越来越多的状态，直到混乱不堪，难以测试……</p>
<p>所以我们看到，在这里，<strong>状态</strong>是导致混乱的最主要原因。实际上，它也是导致很多系统难以测试，经常崩溃的原因。</p>
<h3 id="外部量C何去何从？">外部量C何去何从？</h3><p>但是在很多时候，我们是必须要依赖一些外部的量的，比如刚才的<code>C</code>。我们不希望引入状态，那么就有一个办法，那就是让<code>C</code>变成常量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> C = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这让它人不再能够修改这个量，那么我们就不必要在测试中引入C这个常量了。测试<code>addWithC</code>的代码就可以变得非常地简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'addWithC'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'should return sum of a, b and constant C (which is 1)'</span>, () =&gt; &#123;</span><br><span class="line">        add(<span class="number">1</span>, <span class="number">2</span>).should.equal(<span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 没有副作用</span></span><br><span class="line">        <span class="comment">// 不会有时间的概念</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>让我们思考得更深一点，常量就是什么？实际上就是一个返回固定值的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> C = <span class="number">0</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此<code>addWithC</code>实际上可以是这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addWithC</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + C()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个时候，我们发现<code>C</code>和<code>addWithC</code>都符合一个原则。</p>
<blockquote>
<p>输出仅取决于输入的参数。</p>
</blockquote>
<p>对于这样的函数，我们又称之为<strong>纯函数（Pure function）</strong>，这个概念非常地重要。</p>
<p>奇妙的事情发生了。在一个无状态（Stateless）的世界里，所有的常量都被替换成返回固定值的函数，整个程序的运行无非就是一系列的函数调用。而且，这些函数还都是纯函数！等等，这难道不就是——</p>
<blockquote>
<p><strong>函数是一等公民</strong>。（Function is first-class citizen）</p>
</blockquote>
<p>这是学过JavaScript语言的人都耳熟能详一句话了，但是还是不够准确。毕竟在无状态的世界里，我们就可以用函数来抽象出所有的量了，那么更准确地说——</p>
<blockquote>
<p><strong>函数是<em>唯一</em>的一等公民</strong>。（Function is the one and only first-class citizen）</p>
</blockquote>
<p>我还是不满意，我必须强调“纯函数”这个概念。</p>
<blockquote>
<p><strong><em>纯</em>函数是<em>唯一</em>的一等公民</strong>。（Pure function is the one and only first-class citizen）</p>
</blockquote>
<p>这样做的目的只有一个，<strong>没有副作用</strong>。</p>
<p>好了，所有复杂的问题都解决了，我们不要变量，只要常量，所有的事情都用一层层的纯函数调用来解决。程序员们解散吧，这么简单的事情，用不着那么多人来做……</p>
<p>呵呵。</p>
<h3 id="无状态的乌托邦">无状态的乌托邦</h3><p>上面说的这个世界太理想了。</p>
<p>程序语言给予了我们赋值的能力，给予了我们变量，难道我们就轻易地将它们抛弃吗？当然不是的。在一个局限的小范围内，实际上使用状态还是没有问题的。例如，一个简单的<code>for</code>循环本身也是Stateful的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>, upperBound = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; upperBound; i ++) &#123;</span><br><span class="line">    result += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>result</code>本身依赖于<code>i</code>的取值，<code>i</code>也是一个状态。但是，如果它们被放在一个函数里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seriesSum</span> (<span class="params">upperBound</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; upperBound; i ++) &#123;</span><br><span class="line">        result += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来审视<code>seriesSum</code>。其输出依然是取决于其输入，哦耶！它还是一个纯函数，虽然它内部不是纯函数。<code>seriesSum</code>依然是一个很容易测试的单元。</p>
<p>需要注意的一点是，如果一个函数的输出取决于一个非纯函数的输出的话，那么它一定也不是纯函数。例如下面的场景中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这不是一个纯函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 结果依赖于foo，依然不是一个纯函数</span></span><br><span class="line">    result = foo(arg1, arg2) + ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖注入（Dependency_Injection）">依赖注入（Dependency Injection）</h3><p>如果你接触过<a href="https://angularjs.org/" target="_blank" rel="external">Angular.js</a>，你一定知道依赖注入（Dependency Injection）。</p>
<p>纯函数之所以易于测试，从某种角度上说是因为它的所有依赖就是它的参数，所以我们可以很容易地在测试的时候模拟其所有需要的依赖的变化进行测试。</p>
<p>依赖注入通过给所有我们需要用到的函数、量统一包装，也能实现类似的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'myModule'</span>, [])</span><br><span class="line">.factory(<span class="string">'serviceId'</span>, [<span class="string">'depService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">depService</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;])</span><br><span class="line">.directive(<span class="string">'directiveName'</span>, [<span class="string">'depService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">depService</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;])</span><br><span class="line">.filter(<span class="string">'filterName'</span>, [<span class="string">'depService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">depService</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<p>例如在上面的例子中，如果我们要测试<code>serviceId</code>、<code>directiveName</code>或者<code>filterName</code>的话，那么只需要注入<code>depService</code>就好了。所以，依赖注入提供了跟虚函数一样的依赖跟踪性质，并且相对而言更加分散。但是依赖注入并不能保证每个模块暴露出来的都是虚函数。</p>
<h3 id="面向对象怎么办？">面向对象怎么办？</h3><p>好问题。（咦，好像夸的是我自己……）</p>
<p>一个对象内部的属性如果发生了变化，那么这个对象本质上就不再是之前那个对象了。例如下面的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        <span class="keyword">this</span>.someVar = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    incSomeVar() &#123;</span><br><span class="line">        <span class="keyword">this</span>.someVar++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> MyClass()</span><br><span class="line">myObj.incSomeVar()</span><br><span class="line"><span class="comment">// myObj.someVar变化了</span></span><br><span class="line"><span class="comment">// 她便再也不是从前那个专一（1）的她…</span></span><br></pre></td></tr></table></figure>
<p>我们不希望这样的事情发生，但又希望做出良好的封装性，那么怎么办呢？答案是让类实例不可变（Immuatable）。每次在对象内部的属性变化的时候，我们不直接修改这个对象，而是返回一个新的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    constructor (someVar = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.someVar = someVar</span><br><span class="line">    &#125;</span><br><span class="line">    incSomeVar() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClass(<span class="keyword">this</span>.someVar + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> MyClass()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.someVar) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> mySecondObj = myObj.incSomeVar()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.someVar) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(mySecondObj.someVar) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 两者不指向同样的内存区域，故为false</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj == mySecondObj)</span><br></pre></td></tr></table></figure>
<p>这样做的理由很简单，产生一个新的对象不会对现有的对象产生影响，因此这个操作是<strong>没有副作用</strong>的，符合我们前面提到的我们的目标。</p>
<p>在JavaScript的世界里面，我们有<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">Immutable.js</a>。Immutable.js封装了JavaScript原生类型的Immutable版本。例如<code>Immutable.Map</code>就是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = Immutable.Map(&#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> map2 = map1.set(<span class="string">'b'</span>, <span class="number">50</span>);</span><br><span class="line">map1.get(<span class="string">'b'</span>); <span class="comment">// 2</span></span><br><span class="line">map2.get(<span class="string">'b'</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>实际上，在immutable的世界里，每一个对象永远都是它自己，不会被修改。所以，它可以被视为一个常量，被视为一个返回常量的值。这里精彩的部分在于：</p>
<blockquote>
<p>Hey，Immutable将变量给常量化了！</p>
</blockquote>
<p>显而易见，这样做看似会导致很多不必要的内存开销。其实Immutable数据结构本身会重复利用很多的内存空间，例如链表、Map之类的数据结构，库都会尽量重用可以重用的部分。</p>
<p>在实在无法重用的时候，完全复制在99%的情况下也是没有任何问题的。现在内存那么便宜，你确定你真的对那不必要的几KB几MB的开销很上心吗？大部分时候，并没有必要节约那一点内存，尤其是在浏览器端。</p>
<h3 id="JavaScript与函数式编程">JavaScript与函数式编程</h3><p>最后回到我们最熟悉的JavaScript的函数式编程上来，验证我们之前的一些发现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(i =&gt; i + <span class="number">1</span>)</span><br><span class="line">    .filter(i =&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">    .forEach(i =&gt; <span class="built_in">console</span>.log(i))</span><br><span class="line"><span class="comment">// 输出3 4</span></span><br></pre></td></tr></table></figure>
<p>首先，<code>map</code>、<code>filter</code>返回的都是一个新的数组，不对原有的数组进行修改。这里就表现出了Immutable的特性。其次，我们注意到<code>map</code>、<code>filter</code>和<code>forEach</code>函数都不依赖外界的状态。因此我们可以很容易地把它们拉出来测试。</p>
<p>如果我们依赖了外界的状态，那么就再也不是函数式编程了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> C = <span class="number">1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(i =&gt; i + <span class="number">1</span>)</span><br><span class="line">    .filter(i =&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">    .forEach(i =&gt; <span class="built_in">console</span>.log(i + C))</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>总结下来，保持两点可以让我们的应用维护、测试复杂度显著降低。</p>
<p>第一点就是编写纯函数，保持Stateless，并对其进行测试。需要记住的是，我们不需要将所有的东西都变成Stateless的，至于如何设计那就真的是看经验了。</p>
<p>第二点就是应用Immutable数据结构，将变量常量化。</p>
<p>无论采用什么方法，总体目标就是<strong>消除副作用</strong>。这也是函数作为一等公民，将过程和量统一背后的实际意义。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在学习一些语言的时候，你经常会听到“函数是一等公民”这样的描述。那么究竟函数在这类语言中扮演着怎么样的一个角色？它和函数式编程、无状态设计、封装抽象有什么千丝万缕的联系？</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript闭包的底层运行机制]]></title>
    <link href="http://blog.leapoahead.com/2015/09/15/js-closure/"/>
    <id>http://blog.leapoahead.com/2015/09/15/js-closure/</id>
    <published>2015-09-15T13:17:24.000Z</published>
    <updated>2015-09-16T04:17:41.000Z</updated>
    <content type="html"><![CDATA[<p>我研究JavaScript闭包（closure）已经有一段时间了。我之前只是学会了如何使用它们，而没有透彻地了解它们具体是如何运作的。那么，究竟什么是闭包？</p>
<a id="more"></a>
<p><a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" target="_blank" rel="external">Wikipedia</a>给出的解释并没有太大的帮助。闭包是什么时候被创建的，什么时候被销毁的？具体的实现又是怎么样的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myClosure = (<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> hidden = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inc: <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> hidden++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">myClosure.inc();  <span class="comment">// 返回 1</span></span><br><span class="line">myClosure.inc();  <span class="comment">// 返回 2</span></span><br><span class="line">myClosure.inc();  <span class="comment">// 返回 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相信对JS熟悉的朋友都能很快理解这段代码</span></span><br><span class="line"><span class="comment">// 那么在这段代码运行的背后究竟发生了怎样的事情呢？</span></span><br></pre></td></tr></table></figure>
<p>现在，我终于知道了答案，我感到很兴奋并且决定向大家解释这个答案。至少，我一定是不会忘记这个答案的。</p>
<blockquote>
<p>Tell me and I forget. Teach me and I remember. Involve me and I learn.<br>© Benjamin Franklin</p>
</blockquote>
<p>并且，在我阅读与闭包相关的现存的资料时，我很努力地尝试着去在脑海中想想每个事物之间的联系：对象之间是如何引用的，对象之间的继承关系是什么，等等。我找不到关于这些负责关系的很好的图表，于是我决定自己画一些。</p>
<p>我将假设读者对JavaScript已经比较熟悉了，知道什么是全局对象，知道函数在JavaScript当中是“first-class objects”，等等。</p>
<h3 id="作用域链（Scope_Chain）">作用域链（Scope Chain）</h3><p>当JavaScript在运行的时候，它需要一些空间让它来存储本地变量（local variables）。我们将这些空间称为作用域对象（Scope object），有时候也称作<code>LexicalEnvironment</code>。例如，当你调用函数时，函数定义了一些本地变量，这些变量就被存储在一个作用域对象中。你可以将作用域函数想象成一个普通的JavaScript对象，但是有一个很大的区别就是你不能够直接在JavaScript当中直接获取这个对象。你只可以修改这个对象的属性，但是你不能够获取这个对象的引用。</p>
<p>作用域对象的概念使得JavaScript和C、C++非常不同。在C、C++中，本地变量被保存在栈（stack）中。<strong>在JavaScript中，作用域对象是在堆中被创建的（至少表现出来的行为是这样的），所以在函数返回后它们也还是能够被访问到而不被销毁。</strong></p>
<p>正如你做想的，作用域对象是可以有父作用域对象（parent scope object）的。当代码试图访问一个变量的时候，解释器将在当前的作用域对象中查找这个属性。如果这个属性不存在，那么解释器就会在父作用域对象中查找这个属性。就这样，一直向父作用域对象查找，直到找到该属性或者再也没有父作用域对象。我们将这个查找变量的过程中所经过的作用域对象乘坐作用域链（Scope chain）。</p>
<p>在作用域链中查找变量的过程和原型继承（prototypal inheritance）有着非常相似之处。但是，非常不一样的地方在于，当你在原型链（prototype chain）中找不到一个属性的时候，并不会引发一个错误，而是会得到<code>undefined</code>。但是如果你试图访问一个作用域链中不存在的属性的话，你就会得到一个<code>ReferenceError</code>。</p>
<p>在作用域链的最顶层的元素就是全局对象（Global Object）了。运行在全局环境的JavaScript代码中，作用域链始终只含有一个元素，那就是全局对象。所以，当你在全局环境中定义变量的时候，它们就会被定义到全局对象中。当函数被调用的时候，作用域链就会包含多个作用域对象。</p>
<h3 id="全局环境中运行的代码">全局环境中运行的代码</h3><p>好了，理论就说到这里。接下来我们来从实际的代码入手。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_script.js</span></span><br><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>我们在全局环境中创建了两个变量。正如我刚才所说，此时的作用域对象就是全局对象。</p>
<img src="/2015/09/15/js-closure/js_closure_1.png" alt="在全局环境中创建两个变量" title="在全局环境中创建两个变量">
<p>在上面的代码中，我们有一个执行的上下文（<strong>myscript.js</strong>自身的代码），以及它所引用的作用域对象。全局对象里面还含有很多不同的属性，在这里我们就忽略掉了。</p>
<h3 id="没有被嵌套的函数（Non-nested_functions）">没有被嵌套的函数（Non-nested functions）</h3><p>接下来，我们看这段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//-- define local-to-function variables</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"inside myFunc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- and then, call it:</span></span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>
<p>当<code>myFunc</code>被定义的时候，<code>myFunc</code>的标识符（identifier）就被加到了当前的作用域对象中（在这里就是全局对象），并且这个标识符所引用的是一个函数对象（function object）。函数对象中所包含的是函数的源代码以及其他的属性。其中一个我们所关心的属性就是内部属性<code>[[scope]]</code>。<code>[[scope]]</code>所指向的就是当前的作用域对象。也就是指的就是函数的标识符被创建的时候，我们所能够直接访问的那个作用域对象（在这里就是全局对象）。</p>
<blockquote>
<p>“直接访问”的意思就是，在当前作用域链中，该作用域对象处于最底层，没有子作用域对象。</p>
</blockquote>
<p>所以，在<code>console.log(&quot;outside&quot;)</code>被运行之前，对象之间的关系是如下图所示。</p>
<img src="/2015/09/15/js-closure/js_closure_2.png" alt="对象之间的关系" title="对象之间的关系">
<p>温习一下。<code>myFunc</code>所引用的函数对象其本身不仅仅含有函数的代码，并且还含有指向其<strong>被创建的时候的作用域对象</strong>。这一点<strong>非常重要！</strong></p>
<p>当<code>myFunc</code>函数被调用的时候，一个新的作用域对象被创建了。新的作用域对象中包含<code>myFunc</code>函数所定义的本地变量，以及其参数（arguments）。这个新的作用域对象的父作用域对象就是在运行<code>myFunc</code>时我们所能直接访问的那个作用域对象。</p>
<p>所以，当<code>myFunc</code>被执行的时候，对象之间的关系如下图所示。</p>
<img src="/2015/09/15/js-closure/js_closure_3.png" alt="对象之间的关系（函数执行后）" title="对象之间的关系（函数执行后）">
<p>现在我们就拥有了一个作用域链。当我们试图在<code>myFunc</code>当中访问某些变量的时候，JavaScript会先在其能直接访问的作用域对象（这里就是<code>myFunc() scope</code>）当中查找这个属性。如果找不到，那么就在它的父作用域对象当中查找（在这里就是<code>Global Object</code>）。如果一直往上找，找到没有父作用域对象为止还没有找到的话，那么就会抛出一个<code>ReferenceError</code>。</p>
<p>例如，如果我们在<code>myFunc</code>中要访问<code>a</code>这个变量，那么在<code>myFunc scope</code>当中就可以找到它，得到值为<code>1</code>。</p>
<p>如果我们尝试访问<code>foo</code>，我们就会在<code>myFunc() scope</code>中得到<code>3</code>。只有在<code>myFunc() scope</code>里面找不到<code>foo</code>的时候，JavaScript才会往<code>Global Object</code>去查找。所以，这里我们不会访问到<code>Global Object</code>里面的<code>foo</code>。</p>
<p>如果我们尝试访问<code>bar</code>，我们在<code>myFunc() scope</code>当中找不到它，于是就会在<code>Global Object</code>当中查找，因此查找到2。</p>
<p>很重要的是，只要这些作用域对象依然被引用，它们就不会被垃圾回收器（garbage collector）销毁，我们就一直能访问它们。当然，<strong>当引用一个作用域对象的最后一个引用被解除的时候，并不代表垃圾回收器会立刻回收它，只是它现在可以被回收了</strong>。</p>
<p>所以，当<code>myFunc()</code>返回的时候，再也没有人引用<code>myFunc() scope</code>了。当垃圾回收结束后，对象之间的关系变成回了调用前的关系。</p>
<img src="/2015/09/15/js-closure/js_closure_2.png" alt="对象之间的关系恢复" title="对象之间的关系恢复">
<p>接下来，为了图表直观起见，我将不再将函数对象画出来。但是，请永远记着，函数对象里面的<code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。</p>
<h3 id="嵌套的函数（Nested_functions）">嵌套的函数（Nested functions）</h3><p>正如前面所说，当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被垃圾回收器回收。但是如果我们在函数当中定义嵌套的函数并且返回，被调用函数的一方所存储呢？（如下面的代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunc() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> innerFunc = myFunc();</span><br></pre></td></tr></table></figure>
<p>你已经知道的是，函数对象中总是有一个<code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的<code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p>
<p>如果我们将这个嵌套函数返回，并被另外一个地方的标识符所引用的话，那么这个嵌套函数及其<code>[[scope]]</code>所引用的作用域对象就不会被垃圾回收所销毁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCounter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter = initial;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    counter += value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: increment,</span><br><span class="line">    get: get</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCounter = createCounter(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCounter.get());   <span class="comment">// 返回 100</span></span><br><span class="line">myCounter.increment(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myCounter.get());   <span class="comment">// 返回 105</span></span><br></pre></td></tr></table></figure>
<p>当我们调用<code>createCounter(100)</code>的那一瞬间，对象之间的关系如下图</p>
<img src="/2015/09/15/js-closure/js_closure_4.png" alt="调用createCounter(100)时对象间的关系" title="调用createCounter(100)时对象间的关系">
<p>注意<code>increment</code>和<code>get</code>函数都存有指向<code>createCounter(100) scope</code>的引用。如果<code>createCounter(100)</code>没有任何返回值，那么<code>createCounter(100) scope</code>不再被引用，于是就可以被垃圾回收。但是因为<code>createCounter(100)</code>实际上是有返回值的，并且返回值被存储在了<code>myCounter</code>中，所以对象之间的引用关系变成了如下图所示</p>
<img src="/2015/09/15/js-closure/js_closure_5.png" alt="调用createCounter(100)后对象间的关系" title="调用createCounter(100)后对象间的关系">
<p>所以，<code>createCounter(100)</code>虽然已经返回了，但是它的作用域对象依然存在，可以<strong>且仅只能</strong>被嵌套的函数（<code>increment</code>和<code>get</code>）所访问。</p>
<p>让我们试着运行<code>myCounter.get()</code>。刚才说过，函数被调用的时候会创建一个新的作用域对象，并且该作用域对象的父作用域对象会是当前可以直接访问的作用域对象。所以，当<code>myCounter.get()</code>被调用时的一瞬间，对象之间的关系如下。</p>
<img src="/2015/09/15/js-closure/js_closure_5.png" alt="调用myCounter.get()对象间的关系" title="调用myCounter.get()对象间的关系">
<p>在<code>myCounter.get()</code>运行的过程中，作用域链最底层的对象就是<code>get() scope</code>，这是一个空对象。所以，当<code>myCounter.get()</code>访问<code>counter</code>变量时，JavaScript在<code>get() scope</code>中找不到这个属性，于是就向上到<code>createCounter(100) scope</code>当中查找。然后，<code>myCounter.get()</code>将这个值返回。</p>
<p>调用<code>myCounter.increment(5)</code>的时候，事情变得更有趣了，因为这个时候函数调用的时候传入了参数。</p>
<img src="/2015/09/15/js-closure/js_closure_6_inc.png" alt="调用myCounter.increment(5)对象间的关系" title="调用myCounter.increment(5)对象间的关系">
<p>正如你所见，<code>increment(5)</code>的调用创建了一个新的作用域对象，并且其中含有传入的参数<code>value</code>。当这个函数尝试访问<code>value</code>的时候，JavaScript立刻就能在当前的作用域对象找到它。然而，这个函数试图访问<code>counter</code>的时候，JavaScript无法在当前的作用域对象找到它，于是就会在其父作用域<code>createCounter(100) scope</code>中查找。</p>
<p>我们可以注意到，在<code>createCounter</code>函数之外，除了被返回的<code>get</code>和<code>increment</code>两个方法，没有其他的地方可以访问到<code>value</code>这个变量了。<strong>这就是用闭包实现“私有变量”的方法</strong>。</p>
<p>我们注意到<code>initial</code>变量也被存储在<code>createCounter()</code>所创建的作用域对象中，尽管它没有被用到。所以，我们实际上可以去掉<code>var counter = initial;</code>，将<code>initial</code>改名为<code>counter</code>。但是为了代码的可读性起见，我们保留原有的代码不做变化。</p>
<p>需要注意的是作用域链是不会被复制的。每次函数调用只会往作用域链下面新增一个作用域对象。所以，如果在函数调用的过程当中对作用域链中的任何一个作用域对象的变量进行修改的话，那么同时作用域链中也拥有该作用域对象的函数对象也是能够访问到这个变化后的变量的。</p>
<p>这也就是为什么下面这个大家都很熟悉的例子会不能产出我们想要的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"myClass"</span>), i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">  elems[i].addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.innerHTML = i;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的循环中创建了多个函数对象，所有的函数对象的<code>[[scope]]</code>都保存着对当前作用域对象的引用。而变量<code>i</code>正好就在当前作用域链中，所以循环每次对<code>i</code>的修改，对于每个函数对象都是能够看到的。</p>
<h3 id="“看起来一样的”函数，不一样的作用域对象">“看起来一样的”函数，不一样的作用域对象</h3><p>现在我们来看一个更有趣的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCounter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCounter1 = createCounter(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> myCounter2 = createCounter(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>当<code>myCounter1</code>和<code>myCounter2</code>被创建后，对象之间的关系为</p>
<img src="/2015/09/15/js-closure/js_closure_7.png" alt="myCounter1和myCounter2被创建后，对象之间的关系" title="myCounter1和myCounter2被创建后，对象之间的关系">
<p>在上面的例子中，<code>myCounter1.increment</code>和<code>myCounter2.increment</code>的函数对象拥有着一样的代码以及一样的属性值（<code>name</code>，<code>length</code>等等），但是它们的<code>[[scope]]</code>指向的是<strong>不一样的作用域对象</strong>。</p>
<p>这才有了下面的结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a = myCounter1.get();   <span class="comment">// a 等于 100</span></span><br><span class="line">b = myCounter2.get();   <span class="comment">// b 等于 200</span></span><br><span class="line"></span><br><span class="line">myCounter1.increment(<span class="number">1</span>);</span><br><span class="line">myCounter1.increment(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">myCounter2.increment(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">a = myCounter1.get();   <span class="comment">// a 等于 103</span></span><br><span class="line">b = myCounter2.get();   <span class="comment">// b 等于 205</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域链和this">作用域链和<code>this</code></h3><p><code>this</code>的值不会被保存在作用域链中，<code>this</code>的值取决于函数被调用的时候的情景。</p>
<blockquote>
<p>译者注：对这部分，译者自己曾经写过一篇更加详尽的文章，请参考<a href="http://blog.leapoahead.com/2015/08/31/understanding-js-this-keyword/">《用自然语言的角度理解JavaScript中的this关键字》</a>。原文的这一部分以及“<code>this</code>在嵌套的函数中的使用”译者便不再翻译。</p>
</blockquote>
<h3 id="总结">总结</h3><p>让我们来回想我们在本文开头提到的一些问题。</p>
<ul>
<li>什么是闭包？闭包就是同时含有对函数对象以及作用域对象引用的最想。实际上，所有JavaScript对象都是闭包。</li>
<li>闭包是什么时候被创建的？因为所有JavaScript对象都是闭包，因此，当你定义一个函数的时候，你就定义了一个闭包。</li>
<li>闭包是什么时候被销毁的？当它不被任何其他的对象引用的时候。</li>
</ul>
<h3 id="专有名词翻译表">专有名词翻译表</h3><p>本文采用下面的专有名词翻译表，如有更好的翻译请告知，尤其是加<code>*</code>的翻译</p>
<ul>
<li>*全局环境中运行的代码：top-level code</li>
<li>参数：arguments</li>
<li>作用域对象：Scope object</li>
<li>作用域链：Scope Chain</li>
<li>栈：stack</li>
<li>原型继承：prototypal inheritance</li>
<li>原型链：prototype chain</li>
<li>全局对象：Global Object</li>
<li>标识符：identifier</li>
<li>垃圾回收器：garbage collector</li>
</ul>
<h3 id="著作权声明">著作权声明</h3><p>本文经授权翻译自<a href="http://dmitryfrank.com/articles/js_closures?utm_source=javascriptweekly&amp;utm_medium=email" target="_blank" rel="external">How do JavaScript closures work under the hood</a>。</p>
<p>译者对原文进行了描述上的一些修改。但在没有特殊注明的情况下，译者表述的意思和原文保持一致。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我研究JavaScript闭包（closure）已经有一段时间了。我之前只是学会了如何使用它们，而没有透彻地了解它们具体是如何运作的。那么，究竟什么是闭包？</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[5分钟内使用React、Webpack与ES6构建应用]]></title>
    <link href="http://blog.leapoahead.com/2015/09/12/react-es6-webpack-in-5-minutes/"/>
    <id>http://blog.leapoahead.com/2015/09/12/react-es6-webpack-in-5-minutes/</id>
    <published>2015-09-12T03:54:02.000Z</published>
    <updated>2015-09-12T18:54:02.000Z</updated>
    <content type="html"><![CDATA[<p>假设你想要非常快速地搭建一个React应用，或者你想快速地搭建用ES6学习React开发的环境，那么这篇文章你一定不想错过。</p>
<a id="more"></a>
<p>我们将使用<a href="https://github.com/webpack/webpack" target="_blank" rel="external">webpack</a>作为打包工具。我们使用webpack来将ES6代码转译成ES5代码，编译Stylus样式等。如果你没有安装webpack则需先安装它。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> webpack</span><br><span class="line">$ npm <span class="keyword">install</span> -<span class="keyword">g</span> webpack-dev-<span class="keyword">server</span></span></span><br></pre></td></tr></table></figure>
<p>如果遇到类似<strong>EACESS</strong>错误，则需要用超级用户的模式运行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> webpack</span><br><span class="line">$ sudo npm <span class="keyword">install</span> -<span class="keyword">g</span> webpack-dev-<span class="keyword">server</span></span></span><br></pre></td></tr></table></figure>
<p>接下来创建项目的目录，并且安装<a href="https://github.com/HenrikJoreteg/hjs-webpack" target="_blank" rel="external">hjs-webpack</a>。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir react-playground &amp;&amp; cd <span class="variable">$_</span></span><br><span class="line"><span class="variable">$ </span>npm init -y</span><br><span class="line"><span class="variable">$ </span>npm install hjs-webpack --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查npm版本</span></span><br><span class="line"><span class="variable">$ </span>npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果npm版本是3.x.x或者更高执行下面这句</span></span><br><span class="line"><span class="variable">$ </span>npm i --save autoprefixer babel babel-loader css-loader json-loader postcss-loader react react-hot-loader style-loader stylus-loader url-loader webpack-dev-server yeticss</span><br></pre></td></tr></table></figure>
<p>hjs-webpack是一个简化webpack配置流程的工具，它免去了配置复杂的webpack选项的流程。</p>
<p>在项目根目录下创建<strong>webpack.config.js</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getConfig = <span class="built_in">require</span>(<span class="string">'hjs-webpack'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = getConfig(&#123;</span><br><span class="line">  <span class="comment">// 入口JS文件的位置</span></span><br><span class="line">  <span class="keyword">in</span>: <span class="string">'src/app.js'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用打包（build）之后将存放在哪个文件夹 </span></span><br><span class="line">  out: <span class="string">'public'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否在每次打包之前将之前的打包文件</span></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  clearBeforeBuild: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>好了，现在所有的配置都完成了！</strong>让我们开始构建React应用吧！创建<strong>src/app.js</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">class MyApp extends React.Component &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return &lt;h1&gt;Wonderful App&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.render(&lt;MyApp /&gt;,</span><br><span class="line">    document.body)</span><br></pre></td></tr></table></figure>
<p>接下来启动webpack的开发服务器。它的主要作用是在后台监控文件变动，在每次我们修改文件的时候动态地帮我们进行打包。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack-dev-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>打开<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a>，你就能看到你刚才创建的React应用了！</p>
<img src="/2015/09/12/react-es6-webpack-in-5-minutes/first-react-app.png" alt="React应用" title="React应用">
<p>注意到，在这里我们已经可以使用ES6的语法来创建应用了。</p>
<h3 id="CSS加载和自动刷新">CSS加载和自动刷新</h3><p>创建<strong>src/style.css</strong>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后在<strong>src/app.js</strong>中加载它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">// 加载CSS</span><br><span class="line">require(<span class="string">'./style.css'</span>)</span><br><span class="line"></span><br><span class="line">class MyApp extends React.Component &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return &lt;h1&gt;Wonderful App&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.render(&lt;MyApp /&gt;,</span><br><span class="line">    document.body)</span><br></pre></td></tr></table></figure>
<p>接下来回到你的页面（不用刷新），Blah！整个页面突然充满了喜庆（又血腥）的红色。</p>
<p>这里你可以注意到两点。第一，CSS可以直接通过JavaScript来加载，这是webpack打包的功能之一，它会加载CSS文件并为我们插入到页面上；第二，我们保存后无需刷新就可以刷新页面，这是webpack-dev-server监控到了文件变化，动态打包后自动为我们刷新了页面。这又称作<strong>live reload</strong>。</p>
<h3 id="总结">总结</h3><p>我们其实还可以使用一些<a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a>的脚手架来生成React应用，但是大部分配置依然复杂。hjs-webpack提供了简洁明了的配置接口，适合快速地搭建项目原型、小型应用的开发或者React学习等目的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设你想要非常快速地搭建一个React应用，或者你想快速地搭建用ES6学习React开发的环境，那么这篇文章你一定不想错过。</p>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://blog.leapoahead.com/categories/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Workshop - 对Express中间件进行单元测试]]></title>
    <link href="http://blog.leapoahead.com/2015/09/09/unittesting-express-middlewares/"/>
    <id>http://blog.leapoahead.com/2015/09/09/unittesting-express-middlewares/</id>
    <published>2015-09-09T11:21:33.000Z</published>
    <updated>2015-09-10T04:36:15.000Z</updated>
    <content type="html"><![CDATA[<p>我最近围绕着Express构建应用，尝试用不同的方法来对Express的中间件进行单元测试。今天通过Workshop的形式，一步一步地向大家介绍我的测试方式。</p>
<a id="more"></a>
<img src="/2015/09/09/unittesting-express-middlewares/unittest.jpeg" alt="unittest.jpeg" title="">
<p>本文要求读者有一定<a href="http://expressjs.com" target="_blank" rel="external">Express.js</a>基础，并对JavaScript的Promise特性有所了解。你可以在<a href="http://www.html5rocks.com/zh/tutorials/es6/promises/" target="_blank" rel="external">这篇文章</a>中学习到关于Promise的基础知识。</p>
<p>请在<a href="https://github.com/tjwudi/unit-testing-express-middlewares-example" target="_blank" rel="external">GitHub</a>上将我们学习用的代码clone到本地的任意目录。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>tjwudi/unit-testing-express-middlewares-example.git</span><br><span class="line"><span class="variable">$ </span>cd unit-testing-express-middlewares-example</span><br><span class="line"><span class="variable">$ </span>git checkout step1  <span class="comment"># 回到第一步</span></span><br><span class="line"><span class="variable">$ </span>npm install</span><br><span class="line"><span class="variable">$ </span>node bin/www</span><br></pre></td></tr></table></figure>
<p>在这个项目中，我们提供一个JSON接口<code>/users/:id</code>，返回对应用户<code>id</code>的用户信息，其中包含该用户所负责的项目（projects）。你可以访问<code>http://localhost:3000/users/1</code>看到下面的返回结果。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">type</span>":<span class="value"><span class="string">"User"</span></span>,</span><br><span class="line">   "<span class="attribute">id</span>":<span class="value"><span class="number">1</span></span>,</span><br><span class="line">   "<span class="attribute">name</span>":<span class="value"><span class="string">"John Wu"</span></span>,</span><br><span class="line">   "<span class="attribute">position</span>":<span class="value"><span class="string">"Software Engineer"</span></span>,</span><br><span class="line">   "<span class="attribute">_id</span>":<span class="value"><span class="string">"UUTpdPICsQSLS5zp"</span></span>,</span><br><span class="line">   "<span class="attribute">projects</span>":<span class="value">[</span><br><span class="line">      &#123;</span><br><span class="line">         "<span class="attribute">type</span>":<span class="value"><span class="string">"Project"</span></span>,</span><br><span class="line">         "<span class="attribute">user_id</span>":<span class="value"><span class="number">1</span></span>,</span><br><span class="line">         "<span class="attribute">id</span>":<span class="value"><span class="number">3</span></span>,</span><br><span class="line">         "<span class="attribute">title</span>":<span class="value"><span class="string">"InterU"</span></span>,</span><br><span class="line">         "<span class="attribute">_id</span>":<span class="value"><span class="string">"QH8MxJKnAsHSwA5X"</span></span><br><span class="line">      </span>&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         "<span class="attribute">type</span>":<span class="value"><span class="string">"Project"</span></span>,</span><br><span class="line">         "<span class="attribute">user_id</span>":<span class="value"><span class="number">1</span></span>,</span><br><span class="line">         "<span class="attribute">id</span>":<span class="value"><span class="number">1</span></span>,</span><br><span class="line">         "<span class="attribute">title</span>":<span class="value"><span class="string">"Midway"</span></span>,</span><br><span class="line">         "<span class="attribute">_id</span>":<span class="value"><span class="string">"UnNJxQ7eopLlWFY1"</span></span><br><span class="line">      </span>&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         "<span class="attribute">type</span>":<span class="value"><span class="string">"Project"</span></span>,</span><br><span class="line">         "<span class="attribute">user_id</span>":<span class="value"><span class="number">1</span></span>,</span><br><span class="line">         "<span class="attribute">id</span>":<span class="value"><span class="number">2</span></span>,</span><br><span class="line">         "<span class="attribute">title</span>":<span class="value"><span class="string">"Esther"</span></span>,</span><br><span class="line">         "<span class="attribute">_id</span>":<span class="value"><span class="string">"gZe3sgOsKxxCXHBA"</span></span><br><span class="line">      </span>&#125;</span><br><span class="line">   ]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常规中间件用法">常规中间件用法</h3><p>在<strong>routes/users.js</strong>中我们可以看到响应该请求的中间件，该请求由三个中间件组成，它们分别负责</p>
<ol>
<li>根据用户id从数据库获取用户对象，赋值给<code>req.user</code></li>
<li>根据用户对象获取其负责的所有项目，赋值给<code>req.projects</code></li>
<li>组合上面两步的结果，返回JSON</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userId = <span class="built_in">parseInt</span>(req.params.id, <span class="number">10</span>);</span><br><span class="line">  User.getUserById(userId).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    req.user = user;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  User.getUserProjects(req.user).then(<span class="function"><span class="keyword">function</span> (<span class="params">projects</span>) </span>&#123;</span><br><span class="line">    req.projects = projects;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  req.user.projects = req.projects;</span><br><span class="line">  res.json(req.user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到目前为止，一切都很完美！接下来我们希望能够针对每个中间件设计单元测试。</p>
<blockquote>
<p>题外话：一般情况下，我们都会先设计单元测试，再进行具体实现。但是在这里出于Workshop目的，我们将顺序反过来。</p>
</blockquote>
<p><strong>单元测试（Unit Testing）</strong>中，我们针对函数这类小型的、符合<a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="external">单一职责原则</a>的功能单元进行测试。但是在对Express中间件进行单元测试的时候，我们可能遇到挑战。</p>
<h3 id="直接对接口测试？">直接对接口测试？</h3><p>首先，我们可能尝试直接用类似<a href="https://github.com/visionmedia/supertest#readme" target="_blank" rel="external">supertest</a>的工具进行测试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"></span><br><span class="line">request(app)</span><br><span class="line">  .get(<span class="string">'/users/1'</span>)</span><br><span class="line">  .expect(<span class="number">200</span>)</span><br><span class="line">  .then(...);</span><br></pre></td></tr></table></figure>
<p>但是这样做实际上已经不是单元测试了，而是对整个请求中涉及的所有中间件测试。如果我们不对这些中间件进行变动，但是插入了新的中间件，也可能导致这个测试失败，所以是不可取的。</p>
<p>为了解决这个为题，我们可以将中间件函数独立暴露出来，方便测试。</p>
<h3 id="Step_2：独立中间件">Step 2：独立中间件</h3><p>首先在<strong>routes/users.js</strong>中，我们将三个中间件单独提取到一个对象中，并暴露给外界。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middlewares = &#123;</span><br><span class="line">  getUserById: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> userId = <span class="built_in">parseInt</span>(req.params.id, <span class="number">10</span>);</span><br><span class="line">    User.getUserById(userId).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">      req.user = user;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getProjectsForUser: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    User.getUserProjects(req.user).then(<span class="function"><span class="keyword">function</span> (<span class="params">projects</span>) </span>&#123;</span><br><span class="line">      req.projects = projects;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  responseUserWithProjects: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    req.user.projects = req.projects;</span><br><span class="line">    res.json(req.user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/:id'</span>,</span><br><span class="line">  middlewares.getUserById,</span><br><span class="line">  middlewares.getProjectsForUser,</span><br><span class="line">  middlewares.responseUserWithProjects</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  router: router,</span><br><span class="line">  middlewares: middlewares</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在<strong>app.js</strong>中的第27行更新router的引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/users'</span>, users.router);</span><br></pre></td></tr></table></figure>
<p>你可以在项目目录下运行下面的命令让所有文件和上面所做的变更同步。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout step2</span><br></pre></td></tr></table></figure>
<h3 id="Step_3：建立测试文件">Step 3：建立测试文件</h3><p>接下来在项目目录下新建测试文件<strong>tests/users.js</strong>。我们将用<a href="https://mochajs.org" target="_blank" rel="external">mocha</a>和<a href="https://github.com/shouldjs/should.js" target="_blank" rel="external">should</a>进行测试。mocha是测试运行工具，用于执行测试；而should则是一个断言（assertion）库。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> mocha</span><br><span class="line">$ npm <span class="keyword">install</span> should <span class="comment">--save-dev</span></span></span><br></pre></td></tr></table></figure>
<p>另外我们使用<a href="https://github.com/howardabrams/node-mocks-http" target="_blank" rel="external">node-mocks-http</a>来创建模拟的<code>req</code>和<code>res</code>对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> node-mocks-<span class="keyword">http</span> <span class="comment">--save-dev</span></span></span><br></pre></td></tr></table></figure>
<p>我们以下面的方式对其中一个中间件进行测试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">var</span> mocksHttp = <span class="built_in">require</span>(<span class="string">'node-mocks-http'</span>);</span><br><span class="line"><span class="keyword">var</span> usersMiddlewares = <span class="built_in">require</span>(<span class="string">'../routes/users'</span>).middlewares;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Users endpoint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  describe(<span class="string">'getUserById middleware'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'should have users object attached to request object'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> request = mocksHttp.createRequest(&#123;</span><br><span class="line">        params: &#123; id: <span class="number">1</span> &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">var</span> response = mocksHttp.createResponse();</span><br><span class="line">      usersMiddlewares.getUserById(request, response, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) done(err);</span><br><span class="line">        should.exist(request.user);</span><br><span class="line">        request.user.should.have.properties([<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'position'</span>]);</span><br><span class="line">        done();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// test other middlewares</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>接下来用mocha运行测试</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mocha tests/users<span class="class">.js</span></span><br><span class="line"></span><br><span class="line">  Users endpoint</span><br><span class="line">    getUserById middleware</span><br><span class="line">      ✓ should have users <span class="tag">object</span> attached to request <span class="tag">object</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> passing (<span class="number">17ms</span>)</span><br></pre></td></tr></table></figure>
<p>你可以在项目目录下运行下面的命令让所有文件和上面所做的变更同步。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout step3</span><br></pre></td></tr></table></figure>
<p>但是现在存在一些问题。</p>
<p><strong>如果<code>next</code>函数没有被执行怎么办？</strong>就如<code>responseUserWithProjects</code>这个中间件一样，它是没有调用<code>next</code>函数的，那么回调函数里的逻辑自然也就不会被触发。所以，这个函数的“出口”也就不唯一了。为了让测试准确，我们必须让其出口是唯一的。</p>
<h3 id="Step_4：单一“出口”_-_Promise">Step 4：单一“出口” - Promise</h3><p>我们尝试将<code>getUserById</code>中间件改写成返回一个Promise的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">getUserById: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userId = <span class="built_in">parseInt</span>(req.params.id, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> userPromise = User.getUserById(userId);</span><br><span class="line">  req.user = userPromise;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将<code>req.user</code>变成了一个会resolve（产生）一个user对象的Promise。那么在<code>getProjectsForUser</code>中，我们使用<code>req.user</code>的方式就会发生变化，同时，我们也让<code>req.project</code>变成一个Promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getProjectsForUser: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> projectsPromise = req.user.then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> User.getUserProjects(user);</span><br><span class="line">  &#125;, next);</span><br><span class="line">  req.projects = projectsPromise;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对最后一个中间件<code>responseUserWithProjects</code>，也做相应的改动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">responseUserWithProjects: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.all([</span><br><span class="line">    req.user,</span><br><span class="line">    req.projects</span><br><span class="line">  ]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = results[<span class="number">0</span>];</span><br><span class="line">    user.projects = results[<span class="number">1</span>];</span><br><span class="line">    res.json(user);</span><br><span class="line">  &#125;, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们在中间件运行的过程中通过Promise来传递我们想要获取并传递的对象。这样做的好处在于，现在我们保证了<code>next</code>函数一定会被运行。整个中间件的“出口”是单一的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should have users object attached to request object'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = mocksHttp.createRequest(&#123;</span><br><span class="line">    params: &#123; id: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> response = mocksHttp.createResponse();</span><br><span class="line">  usersMiddlewares.getUserById(request, response, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) done(err);</span><br><span class="line">    request.user.then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">      user.should.have.properties([<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'position'</span>]);</span><br><span class="line">      done();</span><br><span class="line">    &#125;, done);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你可以在项目目录下运行下面的命令让所有文件和上面所做的变更同步。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout step4</span><br></pre></td></tr></table></figure>
<h3 id="Step_5：对于不调用next的中间件">Step 5：对于不调用<code>next</code>的中间件</h3><p>对于不调用<code>next</code>的中间件，例如<code>responseUserWithProjects</code>，我们可以直接将这个Promise当做中间件函数的返回值返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">responseUserWithProjects: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    req.user,</span><br><span class="line">    req.projects</span><br><span class="line">  ]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = results[<span class="number">0</span>];</span><br><span class="line">    user.projects = results[<span class="number">1</span>];</span><br><span class="line">    res.json(user);</span><br><span class="line">  &#125;, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在测试的时候，我们只需要接着这个Promise往下<code>then</code>我们的测试逻辑即可。在测试逻辑运行前，对<code>res</code>的操作是已经结束了的，所以我们就可以直接对<code>res</code>对象进行断言了。</p>
<p>另外，有了Promise，我们也可以让<code>req.user</code>和<code>req.projects</code>的注入变得异常简单。我们可以使用<code>Promise.resove</code>将测试数据包装成一个会立即resolve的Promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'responseUserWithProjects middleware'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should have user with projects object\'s JSON attached in response'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = mocksHttp.createRequest();</span><br><span class="line">    <span class="keyword">var</span> response = mocksHttp.createResponse();</span><br><span class="line">    request.user = <span class="built_in">Promise</span>.resolve(&#123;<span class="string">"type"</span>:<span class="string">"User"</span>,<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="string">"John Wu"</span>,<span class="string">"position"</span>:<span class="string">"Software Engineer"</span>,<span class="string">"_id"</span>:<span class="string">"UUTpdPICsQSLS5zp"</span>&#125;);</span><br><span class="line">    request.projects = <span class="built_in">Promise</span>.resolve([&#123;<span class="string">"type"</span>:<span class="string">"Project"</span>,<span class="string">"user_id"</span>:<span class="number">1</span>,<span class="string">"id"</span>:<span class="number">3</span>,<span class="string">"title"</span>:<span class="string">"InterU"</span>,<span class="string">"_id"</span>:<span class="string">"QH8MxJKnAsHSwA5X"</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"type"</span>:<span class="string">"Project"</span>,<span class="string">"user_id"</span>:<span class="number">1</span>,<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"title"</span>:<span class="string">"Midway"</span>,<span class="string">"_id"</span>:<span class="string">"UnNJxQ7eopLlWFY1"</span>&#125;,</span><br><span class="line">      &#123;<span class="string">"type"</span>:<span class="string">"Project"</span>,<span class="string">"user_id"</span>:<span class="number">1</span>,<span class="string">"id"</span>:<span class="number">2</span>,<span class="string">"title"</span>:<span class="string">"Esther"</span>,<span class="string">"_id"</span>:<span class="string">"gZe3sgOsKxxCXHBA"</span>&#125;</span><br><span class="line">    ]);</span><br><span class="line">    usersMiddlewares.responseUserWithProjects(request, response)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(response._getData());</span><br><span class="line">        data.should.have.properties([<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'position'</span>, <span class="string">'projects'</span>]);</span><br><span class="line">        data.projects.should.be.an.instanceOf(<span class="built_in">Array</span>);</span><br><span class="line">        data.projects.should.have.length(<span class="number">3</span>);</span><br><span class="line">        done();</span><br><span class="line">      &#125;, done)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可以在项目目录下运行下面的命令让所有文件和上面所做的变更同步。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout step5</span><br></pre></td></tr></table></figure>
<h3 id="Step_7：提高一致性">Step 7：提高一致性</h3><p>我们在上面对于调用<code>next</code>和不调用<code>next</code>的方法做了区分，但是实际上，我们只需要一点改动就能让他们的测试方法一致。</p>
<p>注意到<code>getUserById</code>这个函数本身还没有返回值。我们可以把我们要测试的对象——<code>req.user</code>这个Promise直接作为返回值返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserById: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userId = <span class="built_in">parseInt</span>(req.params.id, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> userPromise = User.getUserById(userId);</span><br><span class="line">  req.user = userPromise;</span><br><span class="line">  next();</span><br><span class="line">  <span class="comment">// 返回待测对象的Promise</span></span><br><span class="line">  <span class="keyword">return</span> req.user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，我们就可以用一样的接口进行测试了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'getUserById middleware'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should have users object attached to request object'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = mocksHttp.createRequest(&#123;</span><br><span class="line">      params: &#123; id: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> response = mocksHttp.createResponse();</span><br><span class="line">    usersMiddlewares.getUserById(request, response <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) done(err);</span><br><span class="line">      request.user.then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">        user.should.have.properties([<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'position'</span>]);</span><br><span class="line">        done();</span><br><span class="line">      &#125;, done);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可以在项目目录下运行下面的命令让所有文件和上面所做的变更同步。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout step6</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>在这样的测试方法中，Promise本身起到了对象的“Placeholder”的作用。其本身一旦创建后就可以被使用，传递给下一个中间件，而不需要创建出回调函数，使得中间件的“出口”变成了多个。</p>
<p>使用Promise同时还允许我们将逻辑变成对象到处传递，我们可以随时将它们抽取出来测试。可见，使用Promise可远远不是让我们摆脱<a href="www.infoq.com/cn/articles/nodejs-callback-hell">Callback Hell</a>那么简单。</p>
<p>另外，单元测试要求我们要能够准确地</p>
<ul>
<li>描述一个功能单元的输入</li>
<li>描述一个功能单元的输出</li>
</ul>
<p>通过这个特点，单元测试就能让我们在设计测试阶段就很好地约束每个函数（或者类方法）对应的功能（或者说scope），让我们更容易写出符合<strong>单一职责原则</strong>的代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我最近围绕着Express构建应用，尝试用不同的方法来对Express的中间件进行单元测试。今天通过Workshop的形式，一步一步地向大家介绍我的测试方式。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[八幅漫画理解使用JSON Web Token设计单点登录系统]]></title>
    <link href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/"/>
    <id>http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/</id>
    <published>2015-09-07T14:43:19.000Z</published>
    <updated>2015-09-08T06:31:10.000Z</updated>
    <content type="html"><![CDATA[<p>上次在<a href="/2015/09/06/understanding-jwt/">《JSON Web Token - 在Web应用间安全地传递信息》</a>中我提到了JSON Web Token可以用来设计单点登录系统。我尝试用八幅漫画先让大家理解如何设计正常的用户认证系统，然后再延伸到单点登录系统。</p>
<a id="more"></a>
<p>如果还没有阅读<a href="/2015/09/06/understanding-jwt/">《JSON Web Token - 在Web应用间安全地传递信息》</a>，我强烈建议你花十分钟阅读它，理解JWT的生成过程和原理。</p>
<h3 id="用户认证八步走">用户认证八步走</h3><p>所谓用户认证（Authentication），就是让用户登录，并且在接下来的一段时间内让用户访问网站时可以使用其账户，而不需要再次登录的机制。</p>
<blockquote>
<p>小知识：可别把用户认证和用户授权（Authorization）搞混了。用户授权指的是规定并允许用户使用自己的权限，例如发布帖子、管理站点等。</p>
</blockquote>
<p>首先，服务器应用（下面简称“应用”）让用户通过Web表单将自己的用户名和密码发送到服务器的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth1.png" alt="用户登录请求" title="用户登录请求">
<p>接下来，应用和数据库核对用户名和密码。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth2.png" alt="核对用户名密码" title="核对用户名密码">
<p>核对用户名和密码成功后，应用将用户的<code>id</code>（图中的<code>user_id</code>）作为JWT Payload的一个属性，将其与头部分别进行Base64编码拼接后签名，形成一个JWT。这里的JWT就是一个形同<code>lll.zzz.xxx</code>的字符串。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth3.png" alt="生成JWT" title="生成JWT">
<p>应用将JWT字符串作为该请求Cookie的一部分返回给用户。注意，在这里必须使用<code>HttpOnly</code>属性来防止Cookie被JavaScript读取，从而避免<a href="http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html" target="_blank" rel="external">跨站脚本攻击（XSS攻击）</a>。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth4.png" alt="在Cookie中嵌入JWT" title="在Cookie中嵌入JWT">
<p>在Cookie失效或者被删除前，用户每次访问应用，应用都会接受到含有<code>jwt</code>的Cookie。从而应用就可以将JWT从请求中提取出来。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth5.png" alt="从Cookie提取JWT" title="从Cookie提取JWT">
<p>应用通过一系列任务检查JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth6.png" alt="jwtauth6.png" title="">
<p>应用在确认JWT有效之后，JWT进行Base64解码（可能在上一步中已经完成），然后在Payload中读取用户的id值，也就是<code>user_id</code>属性。这里用户的<code>id</code>为1025。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth7.png" alt="jwtauth7.png" title="">
<p>应用从数据库取到<code>id</code>为1025的用户的信息，加载到内存中，进行ORM之类的一系列底层逻辑初始化。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth8.png" alt="jwtauth8.png" title="">
<p>应用根据用户请求进行响应。</p>
<img src="/2015/09/07/user-authentication-with-jwt/jwtauth9.png" alt="jwtauth9.png" title="">
<h3 id="和Session方式存储id的差异">和Session方式存储id的差异</h3><p>Session方式存储用户id的最大弊病在于要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。</p>
<p>而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分桶（见[《你所应该知道的A/B测试基础》一文](/2015/08/27/introduction-to-ab-testing/）等。</p>
<p>虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘I/O而言或许是半斤八两。具体是否采用，需要在不同场景下用数据说话。</p>
<h3 id="单点登录">单点登录</h3><p>Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：</p>
<ul>
<li>www.taobao.com</li>
<li>nv.taobao.com</li>
<li>nz.taobao.com</li>
<li>login.taobao.com</li>
</ul>
<p>所以如果要实现在<code>login.taobao.com</code>登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。</p>
<p>使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。因此，我们只需要将含有JWT的Cookie的<code>domain</code>设置为顶级域名即可，例如</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: <span class="string">jwt=lll.zzz.xxx; HttpOnly; max-age=980000; domain=.taobao.com</span></span><br></pre></td></tr></table></figure>
<p>注意<code>domain</code>必须设置为一个点加顶级域名，即<code>.taobao.com</code>。这样，taobao.com和*.taobao.com就都可以接受到这个Cookie，并获取JWT了。</p>
<p>对于JWT的两篇文章有相关问题的同学请直接在下面的评论区与我讨论（请勿邮件讨论）。如果你感兴趣，你可以在下方订阅我的半月刊，我将给你推送更多精彩的内容；）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上次在<a href="/2015/09/06/understanding-jwt/">《JSON Web Token - 在Web应用间安全地传递信息》</a>中我提到了JSON Web Token可以用来设计单点登录系统。我尝试用八幅漫画先让大家理解如何设计正常的用户认证系统，然后再延伸到单点登录系统。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSON Web Token - 在Web应用间安全地传递信息]]></title>
    <link href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/"/>
    <id>http://blog.leapoahead.com/2015/09/06/understanding-jwt/</id>
    <published>2015-09-06T12:25:36.000Z</published>
    <updated>2015-09-07T03:25:36.000Z</updated>
    <content type="html"><![CDATA[<p>JSON Web Token（JWT）是一个非常轻巧的<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank" rel="external">规范</a>。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<a id="more"></a>
<p>让我们来假想一下一个场景。在A用户关注了B用户的时候，系统发邮件给B用户，并且附有一个链接“点此关注A用户”。链接的地址可以是这样的</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">https:</span><span class="comment">//your.awesome-app.com/make-friend/?from_user=B&amp;target_user=A</span></span><br></pre></td></tr></table></figure>
<p>上面的URL主要通过URL来描述这个当然这样做有一个弊端，那就是要求用户B用户是一定要先登录的。可不可以简化这个流程，让B用户不用登录就可以完成这个操作。JWT就允许我们做到这点。</p>
<img src="/2015/09/06/understanding-jwt/jwt.png" alt="JSON Web Token" title="JSON Web Token">
<h3 id="JWT的组成">JWT的组成</h3><p>一个JWT实际上就是一个字符串，它由三部分组成，<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>。</p>
<h5 id="载荷（Payload）">载荷（Payload）</h5><p>我们先将上面的添加好友的操作描述成一个JSON对象。其中添加了一些其他的信息，帮助今后收到这个JWT的服务器理解这个JWT。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">iss</span>": <span class="value"><span class="string">"John Wu JWT"</span></span>,</span><br><span class="line">    "<span class="attribute">iat</span>": <span class="value"><span class="number">1441593502</span></span>,</span><br><span class="line">    "<span class="attribute">exp</span>": <span class="value"><span class="number">1441594722</span></span>,</span><br><span class="line">    "<span class="attribute">aud</span>": <span class="value"><span class="string">"www.example.com"</span></span>,</span><br><span class="line">    "<span class="attribute">sub</span>": <span class="value"><span class="string">"jrocket@example.com"</span></span>,</span><br><span class="line">    "<span class="attribute">from_user</span>": <span class="value"><span class="string">"B"</span></span>,</span><br><span class="line">    "<span class="attribute">target_user</span>": <span class="value"><span class="string">"A"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的前五个字段都是由JWT的标准所定义的。</p>
<ul>
<li><code>iss</code>: 该JWT的签发者</li>
<li><code>sub</code>: 该JWT所面向的用户</li>
<li><code>aud</code>: 接收该JWT的一方</li>
<li><code>exp</code>(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li><code>iat</code>(issued at): 在什么时候签发的</li>
</ul>
<p>这些定义都可以在<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank" rel="external">标准</a>中找到。 </p>
<p>将上面的JSON对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作JWT的<strong>Payload</strong>（载荷）。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJpc<span class="number">3</span>MiOiJKb<span class="number">2</span>huIFd<span class="number">1</span>IEpX<span class="title">VCIsImlhdCI6</span>MTQ<span class="number">0</span>MTU<span class="number">5</span>MzUwMiwiZXhwIjox<span class="label">NDQxNTk0</span><span class="label">NzIyLCJhdWQiOiJ3</span>d<span class="number">3</span>cuZXhhbXBsZS<span class="number">5</span>jb<span class="number">20</span>iLCJzdWIiOiJqc<span class="title">m9</span>ja<span class="number">2</span>V<span class="number">0</span>QGV<span class="number">4</span>YW<span class="number">1</span>wbGUuY<span class="number">29</span>tIiwiZ<span class="label">nJvbV91</span>c<span class="number">2</span>VyIjoiQiIsI<span class="label">nRhcmdldF91</span>c<span class="number">2</span>VyIjoiQSJ<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>如果你使用Node.js，可以用Node.js的包<a href="https://github.com/brianloveswords/base64url" target="_blank" rel="external">base64url</a>来得到这个字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base64url = <span class="built_in">require</span>(<span class="string">'base64url'</span>)</span><br><span class="line"><span class="keyword">var</span> header = &#123;</span><br><span class="line">    <span class="string">"from_user"</span>: <span class="string">"B"</span>,</span><br><span class="line">    <span class="string">"target_user"</span>: <span class="string">"A"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(base64url(<span class="built_in">JSON</span>.stringify(header)))</span><br><span class="line"><span class="comment">// 输出：eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小知识：Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p>
</blockquote>
<h5 id="头部（Header）">头部（Header）</h5><p>JWT还需要一个头部，头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">typ</span>": <span class="value"><span class="string">"JWT"</span></span>,</span><br><span class="line">  "<span class="attribute">alg</span>": <span class="value"><span class="string">"HS256"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法。</p>
<p>对它也要进行Base64编码，之后的字符串就成了JWT的<strong>Header</strong>（头部）。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="label">NiJ9</span></span><br></pre></td></tr></table></figure>
<h5 id="签名（签名）">签名（签名）</h5><p>将上面的两个编码后的字符串都用句号<code>.</code>连接在一起（头部在前），就形成了</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="label">NiJ9</span>.eyJmc<span class="title">m9</span>tX<span class="number">3</span>VzZXIiOiJCIiwidGFyZ<span class="number">2</span>V<span class="number">0</span>X<span class="number">3</span>VzZXIiOiJBI<span class="label">n0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一部分的过程在<a href="https://github.com/brianloveswords/node-jws/blob/master/lib/sign-stream.js" target="_blank" rel="external">node-jws的源码</a>中有体现</p>
</blockquote>
<p>最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用<code>mystar</code>作为密钥的话，那么就可以得到我们加密后的内容</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rSWamyAYwuHC<span class="preprocessor">o7</span>IFAgd<span class="number">1</span>oRpSP<span class="number">7</span><span class="label">nzL7</span>BF<span class="number">5</span>t<span class="number">7</span>ItqpKViM</span><br></pre></td></tr></table></figure>
<p>这一部分又叫做<strong>签名</strong>。</p>
<img src="/2015/09/06/understanding-jwt/sig1.png" alt="签名过程" title="签名过程">
<p>最后将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的JWT</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="label">NiJ9</span>.eyJmc<span class="title">m9</span>tX<span class="number">3</span>VzZXIiOiJCIiwidGFyZ<span class="number">2</span>V<span class="number">0</span>X<span class="number">3</span>VzZXIiOiJBI<span class="label">n0</span>.rSWamyAYwuHC<span class="preprocessor">o7</span>IFAgd<span class="number">1</span>oRpSP<span class="number">7</span><span class="label">nzL7</span>BF<span class="number">5</span>t<span class="number">7</span>ItqpKViM</span><br></pre></td></tr></table></figure>
<p>于是，我们就可以将邮件中的URL改成</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http<span class="variable">s:</span>//your.awesome-app.<span class="keyword">com</span>/<span class="keyword">make</span>-friend/?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure>
<p>这样就可以安全地完成添加好友的操作了！</p>
<p>且慢，我们一定会有一些问题：</p>
<ol>
<li>签名的目的是什么？</li>
<li>Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？</li>
</ol>
<p>让我逐一为你说明。</p>
<h3 id="签名的目的">签名的目的</h3><p>最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。</p>
<p>所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。</p>
<img src="/2015/09/06/understanding-jwt/sig2.png" alt="签名过程" title="签名过程">
<p>服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用<code>alg</code>字段指明了我们的加密算法了。</p>
<p>如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。</p>
<h3 id="信息会暴露？">信息会暴露？</h3><p>是的。</p>
<p>所以，在JWT中，不应该在载荷里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。</p>
<p>但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。</p>
<h3 id="JWT的适用场景">JWT的适用场景</h3><p>我们可以看到，JWT适合用于向Web应用传递一些非敏感信息。例如在上面提到的完成加好友的操作，还有诸如下订单的操作等等。</p>
<p>其实JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。在下一次的文章中，我将为大家系统地总结JWT在用户认证和授权上的应用。如果想要及时地收到下一篇文章的更新，您可以在下方订阅我的半月刊：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JSON Web Token（JWT）是一个非常轻巧的<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32">规范</a>。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[以Node应用为例谈如何管理Web应用的环境常量]]></title>
    <link href="http://blog.leapoahead.com/2015/09/04/managing-env-constants/"/>
    <id>http://blog.leapoahead.com/2015/09/04/managing-env-constants/</id>
    <published>2015-09-03T16:33:51.000Z</published>
    <updated>2015-09-04T07:33:51.000Z</updated>
    <content type="html"><![CDATA[<p>在程序员自己的小世界里，我们一直在和“量”打交道——变量和常量。可是常量真的是一成不变的吗？事实上，常量也分为两种，应用常量（application-specific constant）和环境常量（environment-specific constant）。</p>
<a id="more"></a>
<p>所谓应用常量就是，无论这个应用程序运行在哪里，这个值都是不会变的。例如，对于一个用户模块，用户名的最大长度一直都为25，那么我就可以在配置文件中直接写下这个常量。下面以JavaScript为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> USERNAME_LENGTH_MAX = <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>而所谓环境常量，就是<strong>根据这个应用程序所运行的位置的不同而产生变化，但是在运行期间都不会变化的值</strong>。</p>
<p>举个例子，经典的开发流程有一种是“开发（devlopment）-预发布（staging）-线上（production）”。在这三种环境下，应用程序所使用的数据库一般都是不同的，所以使用的数据库配置也不同。</p>
<img src="/2015/09/04/managing-env-constants/dev-stage-prod.png" alt="开发-预发布-线上的开发流程" title="开发-预发布-线上的开发流程">
<p>如果还使用前面的方式来管理这些值的话，那么就相当地麻烦了。那么如何解决这个问题呢？答案跟应用规模有关。</p>
<h3 id="小型应用：使用环境变量">小型应用：使用环境变量</h3><p>可千万别因为一会儿常量一会儿变量而头疼，待会儿我相信你会清楚的：）</p>
<p>环境变量指的是，在一个机器（环境）中每个应用程序都能访问到的那些变量。举个例子，很多人都有配置Windows或者Linux系统的PATH的经历，PATH就是一个环境变量，在任何应用程序中都可以访问。我们来做一个小实验：</p>
<p>在任意目录下新建一个<strong>print-path.js</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process.env是Node.js运行的时候创建的一个对象</span></span><br><span class="line"><span class="comment">// 里面包含的是它所在的环境中所定义的环境变量</span></span><br><span class="line">console.<span class="function"><span class="title">log</span><span class="params">(process.env.PATH)</span></span></span><br></pre></td></tr></table></figure>
<p>然后运行它</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node <span class="built_in">print</span>-<span class="built_in">path</span>.js</span><br></pre></td></tr></table></figure>
<p>你就会得到类似像下面所示的字符串</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/<span class="symbol">bin:</span>/usr/<span class="symbol">bin:</span>/<span class="symbol">bin:</span>/usr/<span class="symbol">sbin:</span>/<span class="symbol">sbin:</span>/<span class="constant">Users/John/</span>.npm-modules/bin/<span class="symbol">:/usr/local/bin/depot_tools</span><span class="symbol">:/usr/local/Cellar/postgresql/</span><span class="number">9.4</span>.<span class="number">4</span>/bin</span><br></pre></td></tr></table></figure>
<p>正如在Windows下面定义PATH一样，你也可以随意定制自己的环境变量。例如在Linux/Mac OSX环境下，在终端中我们可以用<strong>export 环境变量名=环境变量值</strong>的方法来定义一个环境变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ <span class="keyword">export</span> NAME=Esther</span><br><span class="line">&gt; $ node -e <span class="string">"console.log(process.env.NAME)"</span></span><br><span class="line">&gt; Esther</span><br></pre></td></tr></table></figure>
<p>在第一行中，我们首先用<code>export</code>创建了一个环境变量，名称是<code>NAME</code>，值是<code>Esther</code>。在第二行中，我们用<code>node -e</code>直接运行一段Node.js程序，要求打印出<code>process.env.NAME</code>。第三行是输出的结果，我们可以看到它正确地输出了<code>Esther</code>。</p>
<blockquote>
<p>小知识：我们一般都是用专门的文件来定义环境变量，而不是要用的时候才用<code>export</code>定义的。环境变量其实是针对shell的，我们常用的bash就是一个shell（你可以简单理解成就是Mac自带的那个终端）。使用bash的时候一般将环境变量定义在<code>~/.bashrc</code>中。对于从bash运行的程序，就可以读取其中定义的环境变量。值得一提的是，<code>~/.bashrc</code>里面也是用<code>export</code>来定义环境变量，一样一样的！</p>
</blockquote>
<p>但是有的时候，在一个环境下有多个应用，特别是开发环境的机器（也就是我们码农的机器）。所以，如果将所有环境变量都定义在一块，难免很不方便，容易形成下面这样混乱的<strong>bashrc</strong>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> APP1_NAME=weibo</span><br><span class="line"><span class="built_in">export</span> APP1_DB_NAME=weibo-zhalang</span><br><span class="line"><span class="built_in">export</span> APP2_NAME=twitter</span><br><span class="line"><span class="built_in">export</span> APP2_DB_HOST=twitter-prod-db.db.com</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>所以，我们需要更加好的方法来解决！</p>
<h3 id="使用dotenv">使用dotenv</h3><p>dotenv实际上是一个文件，文件名是<code>.env</code>，一般被我们放在项目的根目录下。例如，下面是一个我自己的项目里面的dotenv文件</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库配置</span></span><br><span class="line"><span class="setting">DB_DIALECT=<span class="value">postgres</span></span></span><br><span class="line"><span class="setting">DB_HOST=<span class="value"><span class="number">10.10</span>.<span class="number">10.10</span></span></span></span><br><span class="line"><span class="setting">DB_PASSWORD=<span class="value">db</span></span></span><br><span class="line"><span class="setting">DB_USER=<span class="value">db</span></span></span><br><span class="line"><span class="setting">DB_PORT=<span class="value"><span class="number">5432</span></span></span></span><br><span class="line"><span class="setting">DB_NAME=<span class="value">webcraft</span></span></span><br><span class="line"><span class="setting">DB_CHARSET=<span class="value">utf8</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Node环境配置</span></span><br><span class="line"><span class="setting">NODE_ENV=<span class="value">development</span></span></span><br></pre></td></tr></table></figure>
<p>利用dotenv，我们就可以定义针对项目的环境变量了。如果dotenv的位置是<strong>/path/to/project/.env</strong>，那么所有在<strong>/path/to/project</strong>目录下运行的文件，其能访问到的环境变量<strong>/path/to/project/.env</strong>定义的环境变量。</p>
<p>说起来有点抽象，我们来动手操作理解一下这个过程。在终端中，我们进行下面的操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/<span class="built_in">test</span> &amp;&amp; <span class="built_in">cd</span> <span class="variable">$_</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'PATH=rats'</span> &gt; .env</span><br><span class="line">$ npm install dotenv</span><br></pre></td></tr></table></figure>
<p>上面所做的事情其实就是新建目录<code>~/test</code>并进入，然后新建一个<code>.env</code>文件。文件内容很简单：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NAME</span>=<span class="string">Lee</span></span><br></pre></td></tr></table></figure>
<p>这相当于为在这个目录下面运行的所有应用程序重新定义环境变量<code>PATH</code>的值为<code>rats</code>。当然，我们还需要一些库的支持，这个库就叫<a href="https://github.com/motdotla/dotenv" target="_blank" rel="external">dotenv</a>。（这里是Node.js版本的，其他语言基本也有自己的dotenv实现，例如php和python）。所以在上面我们用npm安装了这个库。</p>
<p>接下来新建<strong>print-name.js</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载dotenv模块</span></span><br><span class="line"><span class="comment">// 具体用法可以查看文档</span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'dotenv'</span>)</span></span>.<span class="function"><span class="title">load</span><span class="params">()</span></span></span><br><span class="line">console.<span class="function"><span class="title">log</span><span class="params">(process.env.NAME)</span></span></span><br></pre></td></tr></table></figure>
<p>运行后就能看到输出为<code>Lee</code>。</p>
<p>这样做的好处就很明显，在不同的项目目录下应用不同的环境变量，并且它们之间不会互相干扰。</p>
<blockquote>
<p>小挑战：你可能想问，dotenv定义的环境变量可以覆盖bash的环境变量吗？请自己尝试，看看能不能覆盖bash中的PATH变量。</p>
</blockquote>
<p>这些环境变量其实对于这个项目而言就是环境常量。所以，环境常量是对于应用而言的，而环境变量是对于环境而言的。</p>
<p><a href="https://github.com/motdotla/dotenv" target="_blank" rel="external">dotenv</a></p>
<h3 id="-env-example">.env-example</h3><p>每个人的开发机器都不同，就算是同一个项目，所需环境变量也不同。我的数据库地址可能是A，你的则可能是B。因此，每个人的<code>.env</code>都会不同。那么，如何对<code>.env</code>进行源码管理呢？</p>
<p>答案就是，我们为每个人提供一个<code>.env</code>的模板，名字一般是<code>.env-example</code>。当我们将项目clone到本地后，将其复制成<code>.env</code>，然后填上我们自己需要的环境变量。</p>
<p>如果这样做，那么就应该将<code>.env</code>排除在源码管理之外，因为我们不希望它被分享出去。如果使用git作为源码管理工具的话，那么我们就需要在<code>.gitignore</code>中指明忽略<code>.env</code></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Ignore .<span class="keyword">env</span> <span class="keyword">file</span></span><br><span class="line">.<span class="keyword">env</span></span><br></pre></td></tr></table></figure>
<p>可以参考<a href="https://github.com/tjwudi/webcraft" target="_blank" rel="external">我的这个项目的做法</a></p>
<h3 id="中大型项目：将环境常量仓库式集中管理">中大型项目：将环境常量仓库式集中管理</h3><p>中大型项目中要配置的环境常量可能很多，或许会接近两三千哥，不再适合用dotenv管理。</p>
<p>解决的方法只有一个——把它们从代码中独立出来管理。例如，我们用yaml文件定义环境常量，全部放在源码<code>config/env</code>下，其目录结构大致如下。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── application-setting<span class="class">.yaml</span></span><br><span class="line">├── database<span class="class">.yaml</span></span><br><span class="line">├── dinner<span class="class">.yaml</span></span><br><span class="line">├── user<span class="class">.yaml</span></span><br><span class="line">└── 此处省略N个yaml文件</span><br></pre></td></tr></table></figure>
<p>放在源码中的配置文件是给开发环境用的。对于其他环境，例如stage和production，我们可以将它们放在统一的代码仓库下面进行管理。由于配置文件的修改一般都不会是大改，所以我们可以手工维护其一致性，只要保证有类似Code Review或者一些简单的自动化检查的环节来保障就可以保持其有效。</p>
<p>在部署的时候，我们也可以单独部署。在这个过程中，可能需要由我们自己开发部署的工具，或者可以采用一些持续集成平台来进行部署。</p>
<p>综上，不同的大型项目业务环境有不同的选择，但是我认为，对于这些环境常量应该保持两条原则：</p>
<ol>
<li>集中式仓库管理，独立作为一个子系统运作</li>
<li>自动化，这已经是很简单的场景了，完全依靠自动化排错不是问题</li>
</ol>
<h3 id="写在最后">写在最后</h3><p>所谓架构就是对应用程序的一系列选择。做好每一个小的选择，都是对架构的改进。良好的环境常量管理可以让配置流程更加清晰易懂，简单高效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在程序员自己的小世界里，我们一直在和“量”打交道——变量和常量。可是常量真的是一成不变的吗？事实上，常量也分为两种，应用常量（application-specific constant）和环境常量（environment-specific constant）。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Node应用中避免“Dot Hell”]]></title>
    <link href="http://blog.leapoahead.com/2015/09/03/prevent-node-require-dot-hell/"/>
    <id>http://blog.leapoahead.com/2015/09/03/prevent-node-require-dot-hell/</id>
    <published>2015-09-02T16:38:51.000Z</published>
    <updated>2015-09-03T07:38:51.000Z</updated>
    <content type="html"><![CDATA[<p>在Node应用中，我们使用<code>require</code>来加载模块。在目录层次相对复杂的应用中，总是会出现类似<code>require(&#39;../../../../../module&#39;)</code>的调用，我把它称之为Dot Hell。我用了一些时间研究现有的解决方案，并介绍我个人认为最好的方法。</p>
<a id="more"></a>
<img src="/2015/09/03/prevent-node-require-dot-hell/cat.png" alt="cat.png" title="">
<p>在Node中的全局对象是<code>global</code>，它就像浏览器的<code>window</code>对象一样。<code>global</code>对象下面的方法都可以直接调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global.a = <span class="number">1</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'assert'</span>).equal(<span class="number">1</span>, a)</span><br></pre></td></tr></table></figure>
<p>因此最简单的方法，也是我认为最好的方式就是在<code>global</code>下创建一个<code>appRequire</code>方法作为<code>require</code>方法的包装，<code>appRequire</code>方法专门用于调用应用内的包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">global.appRequire = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(path.resolve(__dirname, path))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们的项目目录结构如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── app</span><br><span class="line">│   ├── controller</span><br><span class="line">│   │   └── AppController<span class="class">.js</span></span><br><span class="line">│   ├── model</span><br><span class="line">│   │   └── User<span class="class">.js</span></span><br><span class="line">│   └── view</span><br><span class="line">│       └── AppView<span class="class">.js</span></span><br><span class="line">└── app.js</span><br></pre></td></tr></table></figure>
<p>其中<strong>app.js</strong>是应用的入口。那么我们只需要在<strong>app.js</strong>中应用上面的代码，那么在整个应用程序中就都可以使用了。</p>
<p>例如，现在在<strong>app/controller/AppController.js</strong>中，我们可以用下面的语句调用<strong>app/model/User.js</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> User = appRequire(<span class="string">'app/model/User'</span>)</span><br></pre></td></tr></table></figure>
<p>Oh Yeah! 一切都很优雅，很顺利。</p>
<p>但是一个应用中一定还会有测试代码。以单元测试为例，我们如果用<a href="https://mochajs.org/" target="_blank" rel="external">mocha</a>之类的Task Runner去运行测试的话，就得在每个测试前面都加上这一段代码，这样做很容易出错，而且很麻烦。</p>
<p>所以，我们可以把上述的封装代码单独封装成一个文件<strong>global-bootstrap.js</strong>，在运行mocha的时候，用mocha的require参数来指定每次运行测试之前要加载<strong>global-bootstrap.js</strong>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 用Mocha运行tests文件夹下面的所有测试</span><br><span class="line"># 在运行的时候加载should库，以及我们封装的含有appRequire函数的文件</span><br><span class="line">mocha --require should --require global-bootstrap.js --recursive tests</span><br></pre></td></tr></table></figure>
<h3 id="其他方案">其他方案</h3><p>对于解决这个问题，还有两种方案：<strong>NODE_ENV方案（及其变种）</strong>和<strong>Symlink方案</strong>，你可以<a href="https://gist.github.com/branneman/8048520" target="_blank" rel="external">在这里</a>看到。</p>
<p>我认为应该避免使用这两种方案。虽然这两种方案都可行，但是它们都会可能导致应用自身的目录名和node模块名冲突。例如，在下面的结构中，使用<code>require(&#39;request&#39;)</code>就很容易产生二义性。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules</span><br><span class="line">│   └── <span class="built_in">request</span></span><br><span class="line">└── <span class="built_in">request</span></span><br><span class="line">    └── index.js</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>我一直认为Node的模块引用方式的设计是有问题的，Dot Hell就很能说明这点。而Python相对而言就优雅很多，你可以直接通过路径的形式来导入包（在正确配置的情况下）。本文的解决方案允许我们用类似Python的方式去加载模块，你可以在我的项目<a href="https://github.com/tjwudi/webcraft" target="_blank" rel="external">webcraft</a>中看到其应用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Node应用中，我们使用<code>require</code>来加载模块。在目录层次相对复杂的应用中，总是会出现类似<code>require(&#39;../../../../../module&#39;)</code>的调用，我把它称之为Dot Hell。我用了一些时间研究现有的解决方案，并介绍我个人认为最好的方法。</p>]]>
    
    </summary>
    
      <category term="Engineering" scheme="http://blog.leapoahead.com/categories/Engineering/"/>
    
  </entry>
  
</feed>
